# 资源

以下内容/文件在安卓开发中统称为：资源

- 图片（drawable）
- 页面布局（layout）
- 小图标（mipmap）
- 颜色（colors.xml）
- 字符串（strings.xml）
- 主题（themes.xml)

所有资源会被注册在一个名为 `R`的类中，可以在Java代码部分以静态方式进行引用。关于字符串的特别说明：开发中不推荐使用`魔法值`，规范的做法都是注册到xml中后再引用。

# Activity

## 基础概念

`Activity`是一个可视化界面，可以简单理解为浏览器的一个标签；所有`Activity`类都需要在`AndroidManifest.xml`中注册；`Activity`类一般需要配置对应的布局文件（xml）

自定义的 Activity 需要继承`android.app.Activity`类。

`Activity`类可以类比为Vue中的`<script>`标签，用来定义页面的行为；而布局文件就是`<template>`根标签。

## 启动方式

- 显式启动：通过类对象或类绝对路径，直接指定Activity的Java类进行启动。这样启动的是某一个特定的Activity。
- 隐式启动：在`AndroidManifest.xml`注册时，填写`action`属性，指定`Activity`所能匹配的意图。然后在代码中通过指定`action`属性打开`Activity`，此时可能会出现若干匹配成功的`Activity`（甚至有可能是其他APP提供的`Activity`)，此时系统将会弹窗要求用户进行选择。

## 启动系统提供的Activity

通常使用隐式启动方式，即有可能出现弹窗选择；其中一些操作需要对应权限，需要在Manifest中注册

```java
intent.setAction(指定的Action)
```

常用的Action：

- 打电话：Intent.ACTION_CALL
- 发送短信：Intent.ACTION_SENDTO
- 打开相机：MediaStore.ACTION_IMAGE_CAPUTURE

[更多内容](https://www.runoob.com/w3cnote/android-tutorial-activity.html) : 系统给我们提供的常见的Activity

## 生命周期

基础流程：

1. onCreate()
2. onStart()
3. onResume()
4. `Activity`启动完成正在运行



当有其他`Activity`覆盖在上方时：onPause() ，回到当前`Activity`时： onResume()

当被切换到其他APP时： onStop()，然后：

- 如果应用占用内存过高，会被系统 kill 掉 ，再启动时会从 onCreate()开始
- 如果用户回到当前`Activity`： onRestart() -> onStart()
- 如果退出APP： onDestroy()

## Task（任务栈）

### 基础概念

`Task`是一个拥有栈结构（先进后出）的队列，队列成员为`Activity`，最先进去的称为栈底，最后进的称为栈顶，可以想象堆成一摞的打印纸，或压入弹匣的子弹。 

### Activity的4种启动策略

1. standard（默认）：每一次激活`Activity`时都创建一个实例，压入栈顶。
2. singleTop：如果当前`Activity`激活自己，则不创建新实例（队列数不增加），否则创建。
3. singleTask：如果要激活的`Activity`在栈中存在实例，不创建新实例并把它上方的`Activity`弹出。
4. singleInstance：只创建一个实例，且运行在一个新的`Task`中，这个`Task`中也只有这一个实例，不允许其他`Activity`存在。

### 配置方法

Manifest文件中的 Activity节点增加属性 `android:launchMode="策略名"` 

#### taskAffinity

- `Activity`节点可以配置属性 `android:taskAffinity`，指定了它希望进入的 `Task`栈名称
- 如果`Activity`没有配置，则使用Application的该属性
- 如果Application也没有配置，则使用包名
- Task有affinity属性，值等于根`Activity`的 taskAffinity 值

## 意图(Intent)

### 基础概念

顾名思义，“意图”指的是人想要做某一件事的想法，同一个意图可以有不同的处理、操作方式。

举例：意图是打电话，操作可以是用手机打，也可以是用座机打

有时我们在打开某些文件（比如pdf）时可能出现系统提示选择APP，就是在选择 某一项`操作`去实现"打开该文件"的`意图`

### IntentFlag

#### 基本概念

使用 Intent 启动`Activity`时可以通过指定 `IntentFlag`来对`Activity`的启动策略进行`覆盖`。

```java
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
```

#### 常用值

- FLAG_ACTIVITY_NEW_TASK：根据目标`Activity`的`android:taskAffinity`属性，查找或创建一个`Task`来放置目标`Activity`，如果找到则压入该栈；如果未找到则以该值创建一个`Task`并压入该栈。即在默认情况下为压入当前栈。
- FLAG_ACTIVITY_SINGLE_TOP：同singleTop策略
- FLAG_ACTIVITY_CLEAR_TOP：同singleTask策略
- FLAG_ACTIVITY_REORDER_TO_FRONT：如果栈中已存在目标`Activity`，则将其移动到栈顶。

### Activity间数据传递

#### 基础数据类型

- 传递：使用`Intent `对象的`putExtra`方法，该方法拥有大量重载方法。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用对应数据类型的 `getXXXExtra()` 方法

#### 复杂数据类型

##### Bundle数据包

相比`Intent`的方法，`Bundle`支持更多的数据类型，比如`Bundle`自己，或`ArrayList`

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入 `Bundle` 对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getBundleExtra()`方法

##### Serializable

该类必须实现`Serializable`接口，性能相对较差`不推荐`

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getSerializableExtra()`方法，之后强转类型。 

##### Parcelable

该类必须实现`Parcelable`接口，性能相对较好`推荐`

需要重写方法：

- `describeContents()`方法一般使用默认返回0即可
- `writeToParcel(Parcel dest, int flags)` 方法中，我们需要把该类中需要传递的数据保存到 `dest`对象里（序列化）。
- 另外还需要静态Final方法 `Creator<T> CREATOR` ，定义如何反序列化。

`Android Studio`中在类实现了`Parcelable`接口后，光标指向类名按`Alt+Enter`，选择`Add Parcelable Implementation`，即可自动生成如上方法和对应所需的构造方法；如果类成员中包含其他**复杂数据类型**，则会被该操作忽略，除非该类型也实现了`Parcelable`接口。

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getParcelableExtra()`方法，之后强转类型。 

#### 数据回传

- 在启动`Activity`时使用`startActivityForResult`方法替代`startActivity`方法，该方法需要多传入一个`requestCode`参数，作为唯一标记
- 回传数据：在子`Activity`中调用`setResult`方法，可以指定一个`resultCode`(通常用于标记执行结果)，和一个 `Intent `对象（存放数据）

- 接收数据：在父`Activity`中重写`onActivityResult`方法，方法参数为：`requestCode`（之前传入的该参数）,`resultCode`（子`Activity`回传的code）,`data`（回传的数据）

# AndroidManifest.xml

## 包含内容

该文件中规定了：

- APP在桌面上显示的图标、名称、主题
- 每一个Activity也可以单独设置图标、名称、主题

## 意图过滤器

注册`Activity`时需要使用`<intent-filter>` 标签配置意图过滤器，按如下配置时表示该`Activity`是APP的主入口

```xml
<intent-filter>
	<action android:name="android.intent.action.MAIN"/>
    <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
```

隐式启动的Activity其category必须为DEFAULT，非入口的Activity一般可配置为

```xml
<intent-filter>
	<action android:name="你的Action"/>
    <category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
```

### Data匹配

`<intent-filter>`标签中可以配置 `<data android:mimeType="xxx" android:scheme="xxx" />` 来配置Data匹配规则，`Intent`中通过 `setData()`对应该规则。

# 视图UI组件

## TextView

### 字体大小

- px：以像素为基准设置字体大小
- dp：根据屏幕大小适配字体大小，相同屏幕大小相同dp的字体占屏幕面积比例相同
- sp：在dp基础上，受到系统字体大小设置的影响（**推荐**）

dp转换为px的方法：

1. 通过`Context`类对象，获取值：`context.getResources().getDisplayMetrics().density`，该值含义为`像素密度`，这里定义为`scale`
2. `(int) (dp * scale + 0.5f)`即为px值（四舍五入）

### 字体颜色

#### Java方式

获取到控件对象之后，使用`setTextColor`方法设置。参数可以：

- 从`Color`类中选择

- `8位16进制数`（使用`0x`开头）
- `6位16进制数`，此时`Alpha`值默认为00，即全透明，因此实际上没有意义。

#### XML方式

在XML标签上使用`android:textColor`属性设置。参数可以使用：

- `8位16进制数`(以`#`开头)

- `6位16进制数`(以`#`开头)，此时`Alpha`值默认为FF，即完全不透明，因此通常可以这样使用
- 使用`@color/xxxx`的格式，引用`colors.xml`资源文件中定义好的颜色

### 背景颜色

#### Java方式

获取到控件对象之后

- 使用`setBackgroudColor`方法设置，参数只能为`Color`类
- 使用`setBackgroundResource`方法设置，参数使用`R.color.xxx`的格式，引用`colors.xml`资源文件中定义好的颜色

#### XML方式

在XML标签上使用`android:background`属性设置。参数使用与字体颜色相同

## View和ViewGroup

- View类是安卓所有UI组件的父类，代表了屏幕上一块空白的矩形区域
- ViewGroup类是View的子类，作为其他UI组件的容器使用。主要作用是为其他组件提供位置分区（排版）

### 视图的宽高

#### XML方式

- 宽：`android:layout_width`，高：`android:layout_height`
- 取值可以为：
  - `match_parent`：与上级视图保持一致
  - `warp_content`：根据内部内容决定大小，但不超过上级视图的尺寸
  - 以dp为单位的具体尺寸

#### Java方式

只有当XML中设置的对应属性为`warp_content`时，才可以使用Java方式修改宽高：

1. 调用控件的`getLayoutParams`方法获取布局参数
2. 修改布局参数的`width`和`height`属性；值为以px为单位的整数。
3. 调用控件的`setLayoutParams`方法，传入修改后的布局参数

### 视图间距

#### XML方式

- `android:layout_margin`：外间距，`android:padding`：内间距
- 表示四个方向均为该值，也可以单独指定某一方向的间距

### 视图对齐方式

#### XML方式

- `android:layout_gravity`属性，设置当前视图对于上级视图的对齐方式
- `android:gravity`属性，设置下级视图对当前视图的对齐方式
- 取值可以用`|`表示“且”逻辑

## LinearLayout(线性布局)

`android:orientation`属性规定了它内部元素的排列方式，`horizontal`(横向,默认值 ),`vertical`(竖向)

### 权重式布局

将线性布局的下级元素的宽高的其中之一设置为0，并设置`android:layout_weight`权重属性（整数），此时设置为0的那一项的具体数值将根据权重分得最大宽度的一定比例，如2个元素的权重为1和2，则一个占三分之一，一个占三分之二

## RelativeLayout(相对布局)

相对布局的下级视图的位置由`参照物`决定，参照物可以是`RelativeLayout`自己，或者下级视图的平级视图

在下级视图上可以配置一系列`android:layout_`开头的属性：

- `layout_centerVertical`、`layout_centerHorizontal`，以及所有名称中带`parent` 的属性，其参照物均为`RelativeLayout`，其他属性均需指定一个参照物视图的id
- `android:layout_align`开头的属性，表示当前视图与参照物视图的特定边界对齐

##  TextView、EditText、Button

- TextView类是 View 类的子类，EditText和Button则是TextView的子类。他们具有大量的通用xml属性。
- TextView：文本框
- EditText：输入框
- Button：按钮

##  ImageView

ImageView类是 View类的子类，可以在界面上显示图片（Drawable)。

scaleType属性：

- fitXY：缩放图片，使之充满ImageView，图片的宽高比可能会改变。
- fitStart：保持宽高比缩放，直至能完全显示。并显示在ImageView左上角。
- fitCenter：同上，区别是最终显示位置在中央。
- fitEnd：同上，区别是最终显示位置在右下角
- center：不进行缩放，放在ImageView的中间
- centerCrop：保持宽高比缩放，放在ImageView的中间，直至图片能完全覆盖ImageView
- centerInside：保持宽高比缩放，放在ImageView的中间，直至ImageView完全显示图片

## CheckBox、RadioButton

- Checkbox多选框，checked属性可以设置初始值
- RadioButton单选框，需要和RadioGroup一起使用，表示这一些RadioButton属于同一组，同一组的RadioButton只能被选中一个。
- RadioGroup的orientation属性可以修改其中RadioButton的布局方向
- RadioButton必须设置id值

## SeekBar滑块组件

thumb属性可以指定一个Drawable对象，作为滑块；max属性可以指定最大值，不能指定最小值。  

## ProgressBar进度条组件

属性：

- max：最大值
- progress：当前进度

样式：

- progressBarStyle：转圈形式，无法看到实际进度
- progressBarStyleSmall：小转圈形式
- progressBarStyleLarge：大转圈形式
- progressBarStyleHorizontal：常规水平进度条形式

## 日期时间选择：DatePicker、TimePicker

## Spinner列表选择组件

-  Spinner组件可以通过设置 entries 属性给定一个 string-array 资源来显示简单的一行文字信息
- 当需要显示复杂结构的列表项时需要使用 XXXAdapter 类

### SimpleAdapter

显示简单的动态多文本信息，只能用TextView。它的构造方法：

```java
new SimpleAdapter(Context context, List<? extends Map<String, ?>> data,
            @LayoutRes int resource, String[] from, @IdRes int[] to)
```

- Context ：直接传 this （当前Activity）
- data：一个成员为`Map<String,?>`的List，即数据源。一个Map对应列表一行
-  resource：用于渲染列表的一行的xml布局文件的id，布局文件里规定了每一个文本数据的展示位置，样式

- from：包含Map中的所有key的数组
- to：布局文件中所有需要显示数据的TextView的id
- （from 和 to 中的值会按照给出的顺序进行映射） 

## 布局组件

1. LinearLayout：线性布局
2. RelativeLayout：相对布局
3. TableLayout：表格布局
4. FrameLayout：帧布局，每个子组件为一帧，通常用来制作类gif动画
5. GridLayout：网格布局，类似桌面APP图标结构