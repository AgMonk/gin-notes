# 资源

以下内容/文件在安卓开发中统称为：资源

- 图片（drawable）
- 页面布局（layout）
- 小图标（mipmap）
- 颜色（colors.xml）
- 字符串（strings.xml）
- 主题（themes.xml)

所有资源会被注册在一个名为 `R`的类中，可以在Java代码部分以静态方式进行引用。关于字符串的特别说明：开发中不推荐使用`魔法值`，规范的做法都是注册到xml中后再引用。

# Activity

## 基础概念

`Activity`是一个可视化界面，可以简单理解为浏览器的一个标签；所有`Activity`类都需要在`AndroidManifest.xml`中注册；`Activity`类一般需要配置对应的布局文件（XML）

自定义的 Activity 需要继承`androidx.appcompat.app.AppCompatActivity`类。

`Activity`类可以类比为`Vue`中的`<script>`标签，用来定义页面的行为；而布局文件就是`<template>`根标签。

如果想要允许本应用被其他应用启动，`<activity>`标签上需要配置属性`android:exported="true"`

## 启动方式

- 显式启动：通过类对象或类绝对路径，直接指定Activity的Java类进行启动。这样启动的是某一个特定的Activity。
  - 使用方法：`startActivity(new Intent(this, 目标Activity.class));`
  - 结束Activity：调用`finishi();`

- 隐式启动：在`AndroidManifest.xml`注册时，填写`action`属性，指定`Activity`所能匹配的意图。然后在代码中通过指定意图的`action`属性打开`Activity`，此时可能会出现若干匹配成功的`Activity`（甚至有可能是其他APP提供的`Activity`)，此时系统将会弹窗要求用户进行选择。

## 启动系统提供的Activity

通常使用隐式启动方式，即有可能出现弹窗选择；其中一些操作需要对应权限，需要在Manifest中注册

```java
intent.setAction(指定的Action)
```

常用的Action：

- 打电话：Intent.ACTION_CALL
- 发送短信：Intent.ACTION_SENDTO
- 打开相机：MediaStore.ACTION_IMAGE_CAPUTURE

[更多内容](https://www.runoob.com/w3cnote/android-tutorial-activity.html) : 系统给我们提供的常见的Activity

## 生命周期

基础流程：

1. onCreate()
2. onStart()
3. onResume()
4. `Activity`启动完成正在运行



当有其他`Activity`覆盖在上方时：onPause() ，回到当前`Activity`时： onResume()

当被切换到其他APP时： onStop()，然后：

- 如果应用占用内存过高，会被系统 kill 掉 ，再启动时会从 onCreate()开始
- 如果用户回到当前`Activity`： onRestart() -> onStart()
- 如果退出APP： onDestroy()

## Task（任务栈）

### 基础概念

`Task`是一个拥有栈结构（先进后出）的队列，队列成员为`Activity`，最先进去的称为栈底，最后进的称为栈顶，可以想象堆成一摞的打印纸，或压入弹匣的子弹。 

### Activity的4种启动策略

1. standard（默认）：每一次激活`Activity`时都创建一个实例，压入栈顶。
2. singleTop：如果当前`Activity`激活自己，则不创建新实例（队列数不增加），否则创建。
3. singleTask：如果要激活的`Activity`在栈中存在实例，不创建新实例并把它上方的`Activity`弹出。
4. singleInstance：只创建一个实例，且运行在一个新的`Task`中，这个`Task`中也只有这一个实例，不允许其他`Activity`存在。

### 配置方法

Manifest文件中的 Activity节点增加属性 `android:launchMode="策略名"` 

#### taskAffinity

- `Activity`节点可以配置属性 `android:taskAffinity`，指定了它希望进入的 `Task`栈名称
- 如果`Activity`没有配置，则使用Application的该属性
- 如果Application也没有配置，则使用包名
- Task有affinity属性，值等于根`Activity`的 taskAffinity 值

## 意图(Intent)

### 基础概念

顾名思义，“意图”指的是人想要做某一件事的想法，同一个意图可以有不同的处理、操作方式。

举例：意图是打电话，操作可以是用手机打，也可以是用座机打

有时我们在打开某些文件（比如pdf）时可能出现系统提示选择APP，就是在选择 某一项`操作`去实现"打开该文件"的`意图`

### IntentFlag

#### 基本概念

使用 Intent 启动`Activity`时可以通过指定 `IntentFlag`来对`Activity`的启动策略进行`覆盖`。

```java
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
```

#### 常用值

- FLAG_ACTIVITY_NEW_TASK：根据目标`Activity`的`android:taskAffinity`属性，查找或创建一个`Task`来放置目标`Activity`，如果找到则压入该栈；如果未找到则以该值创建一个`Task`并压入该栈。即在默认情况下为压入当前栈。
- FLAG_ACTIVITY_SINGLE_TOP：同singleTop策略
- FLAG_ACTIVITY_CLEAR_TOP：同singleTask策略
- FLAG_ACTIVITY_REORDER_TO_FRONT：如果栈中已存在目标`Activity`，则将其移动到栈顶。

### Activity间数据传递

#### 基础数据类型

- 传递：使用`Intent `对象的`putExtra`方法，该方法拥有大量重载方法。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用对应数据类型的 `getXXXExtra()` 方法

#### 复杂数据类型

##### Bundle数据包

相比`Intent`的方法，`Bundle`支持更多的数据类型，比如`Bundle`自己，或`ArrayList`

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入 `Bundle` 对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getBundleExtra()`方法

##### Serializable

该类必须实现`Serializable`接口，性能相对较差`不推荐`

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getSerializableExtra()`方法，之后强转类型。 

##### Parcelable

该类必须实现`Parcelable`接口，性能相对较好`推荐`

需要重写方法：

- `describeContents()`方法一般使用默认返回0即可
- `writeToParcel(Parcel dest, int flags)` 方法中，我们需要把该类中需要传递的数据保存到 `dest`对象里（序列化）。
- 另外还需要静态Final方法 `Creator<T> CREATOR` ，定义如何反序列化。

`Android Studio`中在类实现了`Parcelable`接口后，光标指向类名按`Alt+Enter`，选择`Add Parcelable Implementation`，即可自动生成如上方法和对应所需的构造方法；如果类成员中包含其他**复杂数据类型**，则会被该操作忽略，除非该类型也实现了`Parcelable`接口。

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getParcelableExtra()`方法，之后强转类型。 

#### Activity的启动方式

1. 父`Activity`中，在`onCreate()`方法中使用如下方法注册一个`ActivityResultLauncher<Intent>`类型的成员变量

   ```java
   launcher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback<ActivityResult>() {
       @Override
       public void onActivityResult(ActivityResult result) {
           // todo 处理响应结果
       }
   });
   ```

   使用该`launcher`对象的`launch`方法启动意图。当然，这里也可以让当前`Activity`直接实现`ActivityResultCallback<ActivityResult>`接口，然后在第二个参数直接传`this`。

2. 在子`Activity`中调用`setResult`方法，可以指定一个`resultCode`(状态码)，和一个 `Intent `对象（用于存放数据）。其中状态码可以使用一些预设的以`Activity.RESULT_`开头的常量，也可以自定义常量。然后调用`finish()`方法结束该`Activity`

3. 在父`Activity`中的`ActivityResult`对象即可使用`getter`获取到状态码和数据

打开系统相册选择图片示例：

```java
private ActivityResultLauncher<Intent> launcher;
private ImageView iv;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_image_pick);
    
    iv = findViewById(R.id.iv);

    launcher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {
        if (result.getResultCode() == RESULT_OK) {
            Intent intent = result.getData();
            if (intent != null) {
                Uri uri = intent.getData();
                // 设置选中的图片给 ImageView
                iv.setImageURI(uri);
            }
        }
    });

    findViewById(R.id.bt_img_pick).setOnClickListener(v -> {
        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_GET_CONTENT);
        intent.setType("image/*");
        launcher.launch(intent);
    });
}
```



# AndroidManifest.xml

## 包含内容

该文件中规定了：

- APP在桌面上显示的图标、名称、主题
- 每一个Activity也可以单独设置图标、名称、主题

## 意图过滤器

注册`Activity`时需要使用`<intent-filter>` 标签配置意图过滤器，按如下配置时表示该`Activity`是APP的主入口

```xml
<intent-filter>
	<action android:name="android.intent.action.MAIN"/>
    <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
```

隐式启动的Activity其category必须为DEFAULT，非入口的Activity一般可配置为

```xml
<intent-filter>
	<action android:name="你的Action"/>
    <category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
```

### Data匹配

`<intent-filter>`标签中可以配置 `<data android:mimeType="xxx" android:scheme="xxx" />` 来配置Data匹配规则，`Intent`中通过 `setData()`对应该规则。

## 元数据

`<activity>`标签中可以设置元数据标签`<meta-data>`，为`Activity`提供数据，元数据标签需要提供`name`、`value`字段。一般作为配置信息

`Activity`类中通过如下方法获取元数据的值：

```java
//获取包管理器
PackageManager packageManager = getPackageManager();
try {
    //获取当前Activity的信息
    ActivityInfo activityInfo = packageManager.getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);
    //元数据包
    Bundle metaData = activityInfo.metaData;
    // 通过name字段获取value字段
    String value = metaData.getString("name");
} catch (PackageManager.NameNotFoundException e) {
    throw new RuntimeException(e);
}
```

### 为APP定义长按图标时弹出的快捷方式列表

1. 在`res`目录下创建`xml`目录，在其中创建一个`shortcuts.xml`文件

2. 在APP的主`Activity`的配置中添加元数据标签，其中`resource`字段指向该文件

   ```xml
   <meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcuts" />
   ```

3. `shortcuts.xml`文件的内容如下(可以使用右键菜单 - NEW - XML - shortcuts XML File 创建模板)：

   ```xml
   <?xml version ="1.0" encoding="utf-8"?>
   <shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
       <shortcut
           android:enabled="true"
           android:shortcutDisabledMessage="@string/launch_disabled"
           android:shortcutId="SHORTCUT_ID"
           android:shortcutLongLabel="@string/launch_exit_long"
           android:shortcutShortLabel="@string/launch_exit_short">
           <intent
               android:action="android.intent.action.VIEW"
               android:targetClass="com.gin.myapp.activity.SecondActivity"
               android:targetPackage="com.gin.myapp.activity" />
       </shortcut>
   </shortcuts>
   ```

4. 这里被启动的`Activity`，其`exported`值必须为true

   

# Drawalbe

`Drawalbe`为抽象类，包括：图片、色块、画板、背景等。所有`Drawable`资源应当放在`res/drawable`目录下

## Shape(形状图形)

- 右键`drawable`目录，选择 New - Drawable Resource File ， 填写文件名，`Root element`选择`shape`，点击`Finish`创建模板文件
- 图形的形状在`<shape>`标签中的`android:shape`字段中选择，默认为矩形
- `<shape>`标签中可以添加若干标签来定义该图形的不同属性：
  1. `<solid>`：填充颜色，`color`颜色
  2. `<stroke>`：描边相关，`color`颜色，`dashGap`每段虚线的间隔，`dashWidth`虚线宽度，`width`描边厚度
  3. `<corners>`：圆角相关，`radius`设置圆角半径，四个角也可以单独设置
  4. `<size>`：尺寸，可以通过`width`和`height`属性设置宽高
  5. `<padding>`：间隔，设置4个方向的间隔
  6. `<gradient>`：渐变

## 点9图

我们可以把一张常规图片转换为点9图，点9图可以通过选定区域，优化图片的拉伸效果

1. 对一张常规图片右键，选择`Create 9-Patch file`
2. 选定区域
   - 上边缘：表示横向拉伸时只拉伸选定区域
   - 左边缘：表示纵向拉伸时只拉伸选定区域
   - 下边缘：表示控件内部文字的横向显示区域
   - 右边缘：表示控件内部文字的纵向显示区域

## 状态列表图形

根据不同状态显示不同的`drawable`

- 右键`drawable`目录，选择 New - Drawable Resource File ， 填写文件名，`Root element`选择`selector`，点击`Finish`创建模板文件
- 在`<selector>`标签中添加若干`<item>`标签，每一个`<item>`标签表示一套状态条件及其匹配的图形，常用属性有：
  - `drawable`：指定图形，必选
  - `state_pressed`：按下状态（Button)
  - `state_checked`：勾选状态（CheckBox、RadioButton）
  - `state_focused`：获得焦点（EditText）
  - `state_selected`：被选中

# 资源文件

## 从资源文件中读取字符串

通过向`Context`类的`getString`方法传递`R.string.xxxx`既可获取到`strings.xml`文件中配置的对应名称的字符串，而`Activity`为`Context`类的子类，因此可以直接调用该方法。

# 布局组件

## LinearLayout(线性布局)

`android:orientation`属性规定了它内部元素的排列方式，`horizontal`(横向,默认值 ),`vertical`(竖向)

### 权重式布局

将线性布局的下级元素的宽高的其中之一设置为`0dp`，并设置`android:layout_weight`权重属性（整数），此时设置为0的那一项的具体数值将根据权重分得最大宽度的一定比例，如2个元素的权重为1和2，则一个占三分之一，一个占三分之二



如果同级元素中有配置了固定宽/高的元素，那么所有配置权重属性的元素将以剩余部分作为最大宽/高；特例：当只有2个元素，一个固定宽/高，一个配置权重时，权重元素将占满剩余部分。

## RelativeLayout(相对布局)

相对布局的下级视图的位置由`参照物`决定，参照物可以是`RelativeLayout`自己，或者下级视图的平级视图

在下级视图上可以配置一系列`android:layout_`开头的属性：

- `layout_centerVertical`、`layout_centerHorizontal`，以及所有名称中带`parent` 的属性，其参照物均为`RelativeLayout`，其他属性均需指定一个参照物视图的id
- `android:layout_align`开头的属性，表示当前视图与参照物视图的特定边界对齐
- `android:layout_toStartOf`表示当前视图的“尾部”与参照物视图的“头部”对齐
- `android:layout_toEndOf`表示当前视图的“头部”与参照物视图的“尾部”对齐

## GridLayout(网格布局)

支持多行多咧表格排列，默认从左往右，从上到下

- `android:columnCount`：列数，当下级视图数量超过该数时，自动换行
- `android:rowCount`：行数

也可以使用权重式布局，但属性名称分为两个：`android:layout_columnWeight`、`android:layout_rowWeight`



# 视图UI组件

## TextView

### 字体大小

- px：以像素为基准设置字体大小
- dp：根据屏幕大小适配字体大小，相同屏幕大小相同dp的字体占屏幕面积比例相同
- sp：在dp基础上，受到系统字体大小设置的影响（**推荐**）

dp转换为px的方法：

1. 通过`Context`类对象，获取值：`context.getResources().getDisplayMetrics().density`，该值含义为`像素密度`，这里定义为`scale`
2. `(int) (dp * scale + 0.5f)`即为px值（四舍五入）

### 字体颜色

#### Java方式

获取到控件对象之后，使用`setTextColor`方法设置。参数可以：

- 从`Color`类中选择

- `8位16进制数`（使用`0x`开头）
- `6位16进制数`，此时`Alpha`值默认为00，即全透明，因此实际上没有意义。

#### XML方式

在XML标签上使用`android:textColor`属性设置。参数可以使用：

- `8位16进制数`(以`#`开头)

- `6位16进制数`(以`#`开头)，此时`Alpha`值默认为FF，即完全不透明，因此通常可以这样使用
- 使用`@color/xxxx`的格式，引用`colors.xml`资源文件中定义好的颜色

### 背景颜色

#### Java方式

获取到控件对象之后

- 使用`setBackgroudColor`方法设置，参数只能为`Color`类
- 使用`setBackgroundResource`方法设置，参数使用`R.color.xxx`的格式，引用`colors.xml`资源文件中定义好的颜色

#### XML方式

在XML标签上使用`android:background`属性设置。参数使用与字体颜色相同

## View和ViewGroup

- View类是安卓所有UI组件的父类，代表了屏幕上一块空白的矩形区域
- ViewGroup类是View的子类，作为其他UI组件的容器使用。主要作用是为其他组件提供位置分区（排版）

### 视图的宽高

#### XML方式

- 宽：`android:layout_width`，高：`android:layout_height`
- 取值可以为：
  - `match_parent`：与上级视图保持一致
  - `warp_content`：根据内部内容决定大小，但不超过上级视图的尺寸
  - 以dp为单位的具体尺寸

#### Java方式

只有当XML中设置的对应属性为`warp_content`时，才可以使用Java方式修改宽高：

1. 调用控件的`getLayoutParams`方法获取布局参数
2. 修改布局参数的`width`和`height`属性；值为以px为单位的整数。
3. 调用控件的`setLayoutParams`方法，传入修改后的布局参数

### 视图间距

#### XML方式

- `android:layout_margin`：外间距，`android:padding`：内间距
- 表示四个方向均为该值，也可以单独指定某一方向的间距

### 视图对齐方式

#### XML方式

- `android:layout_gravity`属性，设置当前视图对于上级视图的对齐方式
- `android:gravity`属性，设置下级视图对当前视图的对齐方式
- 取值可以用`|`表示“且”逻辑

## ScrollView和HorizontalScrollView(滚动视图)

- ScrollView为纵向滚动，`android:layout_height`属性应当设置为`warp_content`
- HorizontalScrollView为横向滚动，`android:layout_width`属性应当设置为`warp_content`

##  Button(按钮)

继承于`TextView`，默认配置了背景颜色，文字居中，并将英文全部转换为大写。

- `android:textAllCaps`：设置为false关闭自动大写

### 点击事件

通过`setOnClickListener`方法绑定事件，需要提供一个`View.OnClickListener`接口，可以使用匿名内部类、lambda、或自定义一个类对其进行实现，如果使用具名内部类应使用静态内部类。

或也可以让当前类实现`View.OnClickListener`接口，`setOnClickListener`方法传`this`，目的为让本视图内的所有点击事件均走同一如空，并通过`onClick(View view)`方法的参数判断点击的是哪一个控件，进而执行不同的逻辑

### 长按事件

长按时间超过500ms的为长按

通过`setOnLongClickListener`方法，提供`View.OnLongClickListener`接口来实现。其中`onLongClick`需要返回一个`boolean`，表示是否消耗该事件，如果不消耗则也会触发`点击事件`，并且会触发上级视图的长按事件。

### 可用状态

XML通过`android:enabled`属性设置按钮的可用性，JAVA使用`setEnabled`方法

##  ImageView(图片)

`ImageView`类是 `View`类的子类，可以在界面上显示图片（Drawable)。

### 图片地址

`android:src`属性指定了图片地址，值可以`@drawable/xxx`格式显示`drwaable`资源目录下的图片（包括常规图片和xml矢量图）

JAVA中使用`setImageResource`方法设置

### 适应策略

`android:scaleType`属性（适应策略）：

- `fitXY`：缩放图片，使之充满ImageView，图片的宽高比可能会改变。
- `fitStart`：保持宽高比缩放，直至能完全显示。并显示在ImageView左上角。
- `fitCenter`：(默认值)同上，区别是最终显示位置在中央。
- `fitEnd`：同上，区别是最终显示位置在右下角
- `center`：不进行缩放，放在ImageView的中间
- `centerCrop`：保持宽高比缩放，放在ImageView的中间，直至图片能完全覆盖ImageView
- `centerInside`：保持宽高比缩放，放在ImageView的中间，直至ImageView完全显示图片

JAVA中使用`setScaleType`方法设置，参数为枚举类型

## ImageButton(图片按钮)

`ImageButton`继承自`ImageView`

- 只能显示图片不能显示文本
- 图像可按比例缩放
- 可设置前景+背景，实现叠加显示。
- 默认适应策略为`center`

## 同时显示文本+图像的方案

1. 使用`LinearLayout`（或其他布局），将`TextView`和`ImageView`组合为一个控件
2. 设置`Button`控件的`drawable****`属性设置图标

## CheckBox(复选框)

XML

- `text`：复选框后的文字
- `checked`：是否选中（初始值）
- `button`：提供一个`drawable`（一般应该为`selector`）替换复选框图标

Java：

- `setOnCheckedChangeListener`：指定当勾选状态改变时执行的回调方法
- `setChecked`：设置勾选状态
- `setButtonDrawable`：设置复选框图标

## Switch(开关)

`Android Studio`会推荐使用`SwitchCompat`类

Java：

- `text`：开关左边的文字，文字为左对齐，开关本体为右对齐
- `setOnCheckedChangeListener`：指定当勾选状态改变时执行的回调方法
- `setChecked`：设置勾选状态

## Radio(单选框)

实际使用的是`RadioGroup`（单选框组）和`RadioButton`（单选框）类，`RadioGroup`中可以放若干个`RadioButton`，代表它们属于同一组，同一组中的单选框只能被选中一个。每一个`RadioButton`均必须设置ID，回调方法时会用到

XML：

- `orientation`：指定单选框的排列方向，默认垂直

Java：

- `RadioGroup`上使用`setOnCheckedChangeListener`绑定勾选状态改变的回调方法，将会返回当前被选中的`RadioButton`的id

## EditText(文本输入框)

XML

- `hint`：占位提示，相当于HTML的placeholder
- `inputType`：输入类型，常用值：文本，密码，数字密码，整数，小数，带符号整数等
- `maxLength`：最大输入长度

Java

- `setOnFocusChangeListener`：设置焦点状态的变更监听
- `addTextChangedListener`：设置文本变化的监听

## AlertDialog(提醒框)

一个包含标题，正文，肯定、否定、(中性)按钮的简单提示框

使用范例：

```java
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle("标题");
builder.setMessage("正文");
builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        Log.i(TAG, "onClick: 确定");
    }
});

builder.setNegativeButton("取消", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        Log.i(TAG, "onClick: 取消");
    }
});
AlertDialog alertDialog = builder.create();
alertDialog.show();
```

## DatePickerDialog(日期选择弹窗)

使用范例：

```java
ZonedDateTime zdt = ZonedDateTime.now();
DatePickerDialog datePickerDialog = new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() {
    @Override
    public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
        Log.i(TAG, String.format("%d %d %d", year, month + 1, dayOfMonth));
    }
}, zdt.getYear(), zdt.getMonthValue() - 1, zdt.getDayOfMonth());
datePickerDialog.show();
```

简化处理类，参数使用`ZonedDateTime`：

```java
/**
 * 自定义日期选择弹窗
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/3 11:43
 **/
public class MyDatePickerDialog {
    DatePickerDialog dialog;

    public MyDatePickerDialog(Context context,OnDateSetListener listener) {
        this.dialog = new DatePickerDialog(context,
                listener,
                listener.zdt.getYear(),
                listener.zdt.getMonthValue()-1,
                listener.zdt.getDayOfMonth());
    }

    public static abstract class OnDateSetListener implements DatePickerDialog.OnDateSetListener {
        final ZonedDateTime zdt;

        public OnDateSetListener(ZonedDateTime zdt) {
            this.zdt = zdt;
        }

        public OnDateSetListener() {
            this(ZonedDateTime.now());
        }

        @Override
        public final void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
            onDateSet(view,zdt.withYear(year).withMonth(month+1).withDayOfMonth(dayOfMonth));
        }

        protected abstract void onDateSet(DatePicker view, ZonedDateTime zonedDateTime);
    }
}
```

## Spinner(下拉框选择)

   XML

- `spinnerMode`：配置下拉框是常规模式(`dropdown`)还是弹窗模式(`dialog`)

示例：

```java
public static final String TAG = "SPINNER";
public static final String[] OPTIONS = new String[]{"AA", "BB", "CC", "DD"};
private Spinner spinner;
private ArrayAdapter<String> arrayAdapter;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_spinner);

    spinner = findViewById(R.id.sp_dropdown);
    // 创建适配器 ，布局文件 R.layout.item_spinner 中仅有一个 TextView
    arrayAdapter = new ArrayAdapter<>(this, R.layout.item_spinner, OPTIONS);
    // 设置适配器
    spinner.setAdapter(arrayAdapter);
    // 设置弹窗标题(仅dialog模式)
    spinner.setPrompt("弹窗标题");
    // 默认选中第一个
    spinner.setSelection(0);
    // 选项变更的监听
    spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            if (parent.getId() == R.id.sp_dropdown) {
                Log.i(TAG, "onItemClick: p:" + position + " id:" + id);
            } else {
                Log.i(TAG, "onItemClick: ??");
            }
            Log.i(TAG, "onItemClick: " + parent.getClass());
            Log.i(TAG, "onItemClick: " + view.getClass());
        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {
            Log.i(TAG, "onItemClick: " + parent.getClass());
        }
    });
}
```

## ListView(列表)

XML：

`layout_height`属性需设置为`wrap_content`

列表条目的根组件上配置属性`android:descendantFocusability="blocksDescendants"`，可避免下级元素获得焦点，影响条目的点击事件触发

JAVA：

使用适配器插入数据即可

## GridView(网格)



## SeekBar滑块组件

thumb属性可以指定一个Drawable对象，作为滑块；max属性可以指定最大值，不能指定最小值。  

## ProgressBar进度条组件

属性：

- max：最大值
- progress：当前进度

样式：

- progressBarStyle：转圈形式，无法看到实际进度
- progressBarStyleSmall：小转圈形式
- progressBarStyleLarge：大转圈形式
- progressBarStyleHorizontal：常规水平进度条形式

# SharedPreferences(共享参数)

用于存储简单数据，使用键值对方式存储到私有目录的`shared_prefs/xxxx.xml`文件中，可以保存的类型为：`int`、`float`、`boolean`、`String`、`Long`、`Set<String>`

使用范例：

```java
// 获取 SharedPreferences对象
SharedPreferences sharedPreferences = getSharedPreferences("filename", Context.MODE_PRIVATE);
// 读取
String string = sharedPreferences.getString("key", "defaultValue");
// 修改
SharedPreferences.Editor editor = sharedPreferences.edit();
editor.putString("key", "value");
editor.putString("key2", "value");
// 修改完毕后需要调用 apply 或 commit进行提交
editor.apply();
editor.commit();
```

# SqlLite

轻量单文件SQL数据库，可以指定任意路径保存，一般保存在`getFilesDir()`目录下

创建：

```java
SQLiteDatabase database = openOrCreateDatabase("filepath", Context.MODE_PRIVATE, null);
```

删除：

```java
deleteDatabase("文件路径.db")
```

## SQLLiteOpenHelper

通常使用该类对数据库进行管理

使用范例：

```java
/**
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/3 15:51
 **/
public class MyDBHelper extends SQLiteOpenHelper {
    private static final String NAME = "test.db";
    private static final int VERSION = 1;
    private static MyDBHelper dbHelper;
    private SQLiteDatabase readConnection;
    private SQLiteDatabase writeConnection;

    private MyDBHelper(Context context) {
        super(context, NAME, null, VERSION);
    }

    /**
     * 单例模式
     *
     * @return
     */
    public static MyDBHelper getInstance(Context context) {
        if (dbHelper == null) {
            dbHelper = new MyDBHelper(context);
        }
        return dbHelper;
    }

    /**
     * 获取读连接
     *
     * @return 读连接
     */
    public SQLiteDatabase getReadConnection() {
        if (this.readConnection == null || !this.readConnection.isOpen()) {
            this.readConnection = dbHelper.getReadableDatabase();
        }
        return this.readConnection;
    }

    /**
     * 获取写连接
     *
     * @return 写连接
     */
    public SQLiteDatabase getWriteConnection() {
        if (this.writeConnection == null || !this.writeConnection.isOpen()) {
            this.writeConnection = dbHelper.getWritableDatabase();
        }
        return this.writeConnection;
    }

    /**
     * 关闭所有连接
     */
    public void closeConnections() {
        if (this.readConnection != null && this.readConnection.isOpen()) {
            this.readConnection.close();
            this.readConnection = null;
        }
        if (this.writeConnection != null && this.writeConnection.isOpen()) {
            this.writeConnection.close();
            this.writeConnection = null;
        }
    }


    @Override
    public void onCreate(SQLiteDatabase db) {
        // todo 创建数据库时执行的操作（一般为建表操作）
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // todo 更新数据库版本时执行的操作（更新数据结构）
    }

    /**
     * 插入操作
     *
     * @param tableName 表名
     * @param values    对线值map
     * @return 行号，-1表示插入失败
     */
    public long insert(String tableName, ContentValues values) {
        return getWriteConnection().insert(tableName, null, values);
    }
}
```

## Jetpack-Room

参考：https://blog.csdn.net/zhuowalun8427/article/details/127703090

### 引入依赖

```
implementation "androidx.room:room-runtime:2.2.5"
annotationProcessor "androidx.room:room-compiler:2.2.5" 
```

### 使用步骤

1. 在实体类上使用`@Entity`注解
   1. 在主键（一般为id列）上使用`@PrimaryKey(autoGenerate = true)`注解
   2. 在其他列上使用`@ColumnInfo(name="列名")`注解
2. 创建接口`XXXDao`类，使用`@Dao`注解
   1. 插入/删除/修改方法的定义：参数使用对应的实体类，可以使用可变参数；根据操作类型在方法上使用注解：`@Insert`/`@Delete`/`@Update`
   2. 查询方法的定义：在方法上使用注解`@Query`，返回类型使用对应的实体类或泛型为实体类的列表，注解参数填写查询SQL语句
      - 实体类名即为表名
      - SQL语句中使用`:xxx`的方式引用方法的参数
   3. `@Query`注解实际上代表执行自定义的任意SQL语句，即也可以写其他类型的操作
3. 创建数据库抽象类`MyDatabase`，继承`RoomDatabase`类
   1. 类上使用注解`@Database`，entities属性填写所有的实体类，version属性填写版本，exportSchema设置为false
   2. 该类中提供抽象方法返回`XXXDao`对象
4. 创建数据库对象
   1. `Room.databaseBuilder(this,MyDatabase.class,数据库名称).build()`
   2. 一般来说不允许在主线程创建数据库



## GreenDao

https://blog.csdn.net/Cupster/article/details/114267141

## DBFlow

https://cupster.blog.csdn.net/article/details/114592859

# 外部存储

## 外部私有空间

通过`getExternalFilesDirs(Environment.DIRECTORY_xxxxxxxxxx)`方法获取外部存储的路径，然后直接使用JAVA常规文件操作即可

## 外部公共空间

通过`Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_xxxxxx)`方法获取外部存储的路径，然后直接使用JAVA常规文件操作即可

在`AndroidManifest.xml`中：

1. `<application>`标签需要添加属性`android:requestLegacyExternalStorage="true"`
2. 对于低版本SDK需要申请权限

```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
```

# 读写图片文件

## 读取和显示

使用`BitmapFactory.decodeXXXX`方法从不同来源读取图片，常用的有：

- `decodeResource`：从资源文件中读取，第一个参数可以直接传`getResources()`
- `decodeFile`：从文件中读取
- `decodeStream`：从流中读取

使用`ImageView`的`setImageBitmap`显示`Bitmap`图片；或`setImageURI(Uri.parse(文件路径))`直接显示图片

## 保存图片文件

使用`Bitmap`对象的`compress`方法保存图片为文件（或用流输出）

## 回收

`Bitmap`对象使用完毕之后需要调用`recycle()`方法回收内存。

# Application

应用对象，每个APP只有一个`Application`对象，其生命周期贯穿整个APP的运行过程。可以在其中存储一些全局变量。

# ContentProvider(内容提供者)

用于应用之间的数据共享

## Server端

右键 New - Ohter - Content Provider，其中`URI Authorities`项先填“xxx”。创建完成后`AndroidManifest.xml`文件中会多出一项`<provider>`的配置，将其中的`authorities`属性修改为刚刚创建的Provider的完整类名。



Provider类中已经默认实现了必须的增删改查方法，在其中实现自己的业务逻辑即可。

## Client端

通过`getContentResolver()`方法获得`ContentResolver`对象，该对象中即有对应Provider的增删改查方法，这些方法均需要提供一个URI，该URI的构建格式为：`content://{authorities}/{路径}`，通过`Uri.parse`方法将该字符串解析为`Uri`对象



在`AndroidManifest.xml`中配置

```xml
<queries>
    <package android:name="server端包名"/>
    <!--        或-->
    <provider android:authorities="server端的authorities属性"/>
</queries>
```

## 在URI路径部分传参/规定URI路径

在Provider类中增加如下代码定义，其中`AUTHORITY`为`authorities`属性值，静态块中表示当前两个参数与给定的URI匹配时，返回第三个参数（状态码）。其中`#`表示参数占位符

```java
private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
private static final String AUTHORITY = "com.gin.myapp.activity.activity.MyContentProvider";

static {
    URI_MATCHER.addURI(AUTHORITY, "/user", 200);
    URI_MATCHER.addURI(AUTHORITY, "/user/#", 201);
}
```

然后在业务逻辑中，这样区分不同的路径

```java
switch (URI_MATCHER.match(uri)){
    case 200:break;
    case 201:break;
}
```

# 权限动态请求

部分权限不仅需要在`AndroidManifest.xml`中配置，也需要在使用时向用户请求批准使用

## AndroidManifest.xml配置

示例，申请收发短信权限

```xml
<uses-feature
    android:name="android.hardware.telephony"
    android:required="false" />
<uses-permission android:name="android.permission.READ_SMS"/>
<uses-permission android:name="android.permission.SEND_SMS"/>
<uses-permission android:name="android.permission.READ_CONTACTS" />
<uses-permission android:name="android.permission.WRITE_CONTACTS" />
```

## 动态请求范例

工具类方法：检查当前是否持有给定的所有权限，如果不全持有则弹窗请求授权

```java
public class PermissionUtils {
    /**
     * 检查是否持有给定的所有权限，如果有任一未持有则弹窗请求授权
     *
     * @param activityCompat {@link AppCompatActivity}
     * @param requestCode    请求code
     * @param permissions    权限
     * @return 当前是否持有所有权限
     */
    public static boolean checkPermissions(AppCompatActivity activityCompat, int requestCode, String... permissions) {
        if (permissions == null) {
            return false;
        }
        if (!hasPermissions(activityCompat, permissions)) {
            activityCompat.requestPermissions(permissions, requestCode);
            return false;
        }
        return true;
    }

    /**
     * 判断当前是否持有给定的所有权限
     *
     * @param activityCompat {@link AppCompatActivity}
     * @param permissions    权限
     * @return 是否持有所有权限
     */
    public static boolean hasPermissions(AppCompatActivity activityCompat, String... permissions) {
        if (permissions == null) {
            return false;
        }
        for (String permission : permissions) {
            if (activityCompat.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }
    /**
     * 判断授权结果是否为全部授权
     *
     * @param grantResults 授权结果
     * @return 判断授权结果是否为全部授权
     */
    public static boolean hasPermissions(@NonNull int[] grantResults) {
        for (int grantResult : grantResults) {
            if (grantResult != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }
}
```

Activity中使用：

```java
public static final String TAG = "PermissionActivity";

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_permission);


    findViewById(R.id.permission_sms).setOnClickListener(this);
    findViewById(R.id.permission_contact).setOnClickListener(this);
}

@Override
public void onClick(View v) {
    int id = v.getId();
    if (id == R.id.permission_sms) {
        if (PermissionUtils.checkPermissions(this, 200
                                             , Manifest.permission.READ_SMS, Manifest.permission.SEND_SMS)) {
            //todo 持有权限，执行业务逻辑
            Log.i(TAG, "onClick: 持有短信权限");
        }
    } else if (id == R.id.permission_contact) {
        if (PermissionUtils.checkPermissions(this, 300
                                             , Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS)) {
            //todo 持有权限，执行业务逻辑
            Log.i(TAG, "onClick: 持有联系人权限");
        }
    }
}


/**
     * 请求授权的结果回调
     */
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    if (PermissionUtils.hasPermissions(grantResults)) {
        Log.i(TAG, "onRequestPermissionsResult: 授权成功 code: " + requestCode);
        // todo 执行业务逻辑
    } else {
        Log.i(TAG, "onRequestPermissionsResult: 授权失败 code: " + requestCode);
        jumpToSettings();
    }
}

/**
     * 授权失败，跳转到设置界面
     */
private void jumpToSettings() {
    Intent intent = new Intent();
    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
    intent.setData(Uri.fromParts("package", getPackageName(), null));
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);
}
```

# Adapter(适配器)

## SimpleAdapter

构造方法：

```java
new SimpleAdapter(Context context, List<? extends Map<String, ?>> data,
            @LayoutRes int resource, String[] from, @IdRes int[] to)
```

- Context ：直接传 this （当前Activity）
- data：一个成员为`Map<String,?>`的List，即数据源。一个Map对应列表一行
- resource：用于渲染列表的一行的xml布局文件的id，布局文件中接收数据的组件支持：`ImageView`，`TextView`，继承或实现`Checkable`接口的组件(典型的如：单选框、复选框)

- from：包含Map中的所有key的数组
- to：布局文件中所有需要显示数据的组件的id
- （from 和 to 中的值会按照给出的顺序进行映射） 

## BaseAdapter

当布局格式更复杂时，需要自行定义专用的适配器，实现示例：

```java
/**
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/5 11:48
 **/
public class MyAdapter extends BaseAdapter {
    /**
     * 上下文
     */
    private final Context context;
    /**
     * 数据
     */
    private final List<Object> data;

    public MyAdapter(Context context, List<Object> data) {
        this.context = context;
        this.data = data;
    }

    /**
     * @return 数据条数
     */
    @Override
    public int getCount() {
        return data.size();
    }

    /**
     * @param position 位置
     * @return 指定位置上的数据
     */
    @Override
    public Object getItem(int position) {
        return null;
    }

    /**
     * @param position 位置
     * @return 指定位置上的元素id
     */
    @Override
    public long getItemId(int position) {
        // 不重复即可
        return position;
    }

    /**
     * 返回需要显示的组件
     * @param position    位置
     * @param convertView 当组件元素移出屏幕时将被回收重用
     * @param parent      父组件
     * @return 组件
     */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        if (convertView == null) {
            // 当不是重用时，构造一个新的组件
            convertView = LayoutInflater.from(context).inflate(R.layout.item_spinner, parent, false);
            // 从组件中拿到各组件，放到 ViewHolder 中
            viewHolder = new ViewHolder();
            viewHolder.tv = convertView.findViewById(R.id.iv);
            // 把viewHolder保存到组件中
            convertView.setTag(convertView);
        } else {
            // 当是重用时取出 viewHolder
            viewHolder = (ViewHolder) convertView.getTag();
        }

        // 使用该位置的数据，修改组件中的属性
        Object obj = data.get(position);
        viewHolder.tv.setText(obj.toString());
        //返回组件
        return convertView;
    }

    /**
     * 保存布局文件中需要被操作的组件
     */
    public static class ViewHolder {
        TextView tv;
    }
}
```