# 资源

以下内容/文件在安卓开发中统称为：资源

- 图形/图片（drawable）
- 页面布局（layout）
- 小图标（mipmap）
- 颜色（colors.xml）
- 菜单 (menu)
- 字符串（strings.xml）
- 主题（themes.xml)

所有资源会被注册在一个名为 `R`的类中，可以在Java代码部分以静态方式进行引用。关于字符串的特别说明：开发中不推荐使用`魔法值`，规范的做法都是注册到xml中后再引用。

# Activity

## 基础概念

`Activity`是一个可视化界面，可以简单理解为浏览器的一个标签；所有`Activity`类都需要在`AndroidManifest.xml`中注册；`Activity`类一般需要配置对应的布局文件（XML）

自定义的 Activity 需要继承`androidx.appcompat.app.AppCompatActivity`类。

`Activity`类可以类比为`Vue`中的`<script>`标签，用来定义页面的行为；而布局文件就是`<template>`根标签。

如果想要允许本应用被其他应用启动，`<activity>`标签上需要配置属性`android:exported="true"`

## 启动方式

- 显式启动：通过类对象或类绝对路径，直接指定Activity的Java类进行启动。这样启动的是某一个特定的Activity。
  - 使用方法：`startActivity(new Intent(this, 目标Activity.class));`
  - 结束Activity：调用`finish();`

- 隐式启动：在`AndroidManifest.xml`注册时，填写`action`属性，指定`Activity`所能匹配的意图。然后在代码中通过指定意图的`action`属性打开`Activity`，此时可能会出现若干匹配成功的`Activity`（甚至有可能是其他APP提供的`Activity`)，此时系统将会弹窗要求用户进行选择。

## 启动系统提供的Activity

通常使用隐式启动方式，即有可能出现弹窗选择；其中一些操作需要对应权限，需要在Manifest中注册

```java
intent.setAction(指定的Action)
```

常用的Action：

- 打电话：Intent.ACTION_CALL
- 发送短信：Intent.ACTION_SENDTO
- 打开相机：MediaStore.ACTION_IMAGE_CAPUTURE

[更多内容](https://www.runoob.com/w3cnote/android-tutorial-activity.html) : 系统给我们提供的常见的Activity

## 生命周期

基础流程：

1. onCreate()
2. onStart()
3. onResume()
4. `Activity`启动完成正在运行



当有其他`Activity`覆盖在上方时：onPause() ，回到当前`Activity`时： onResume()

当被切换到其他APP时： onStop()，然后：

- 如果应用占用内存过高，会被系统 kill 掉 ，再启动时会从 onCreate()开始
- 如果用户回到当前`Activity`： onRestart() -> onStart()
- 如果退出APP： onDestroy()

## Task（任务栈）

### 基础概念

`Task`是一个拥有栈结构（先进后出）的队列，队列成员为`Activity`，最先进去的称为栈底，最后进的称为栈顶，可以想象堆成一摞的打印纸，或压入弹匣的子弹。 

### Activity的4种启动策略

1. standard（默认）：每一次激活`Activity`时都创建一个实例，压入栈顶。
2. singleTop：如果当前`Activity`激活自己，则不创建新实例（队列数不增加），否则创建。
3. singleTask：如果要激活的`Activity`在栈中存在实例，不创建新实例并把它上方的`Activity`弹出。
4. singleInstance：只创建一个实例，且运行在一个新的`Task`中，这个`Task`中也只有这一个实例，不允许其他`Activity`存在。

### 配置方法

Manifest文件中的 Activity节点增加属性 `android:launchMode="策略名"` 

#### taskAffinity

- `Activity`节点可以配置属性 `android:taskAffinity`，指定了它希望进入的 `Task`栈名称
- 如果`Activity`没有配置，则使用Application的该属性
- 如果Application也没有配置，则使用包名
- Task有affinity属性，值等于根`Activity`的 taskAffinity 值

## 意图(Intent)

### 基础概念

顾名思义，“意图”指的是人想要做某一件事的想法，同一个意图可以有不同的处理、操作方式。

举例：意图是打电话，操作可以是用手机打，也可以是用座机打

有时我们在打开某些文件（比如pdf）时可能出现系统提示选择APP，就是在选择 某一项`操作`去实现"打开该文件"的`意图`

### IntentFlag

#### 基本概念

使用 Intent 启动`Activity`时可以通过指定 `IntentFlag`来对`Activity`的启动策略进行`覆盖`。

```java
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
```

#### 常用值

- FLAG_ACTIVITY_NEW_TASK：根据目标`Activity`的`android:taskAffinity`属性，查找或创建一个`Task`来放置目标`Activity`，如果找到则压入该栈；如果未找到则以该值创建一个`Task`并压入该栈。即在默认情况下为压入当前栈。
- FLAG_ACTIVITY_SINGLE_TOP：同singleTop策略
- FLAG_ACTIVITY_CLEAR_TOP：同singleTask策略
- FLAG_ACTIVITY_REORDER_TO_FRONT：如果栈中已存在目标`Activity`，则将其移动到栈顶。

### Activity间数据传递

#### 基础数据类型

- 传递：使用`Intent `对象的`putExtra`方法，该方法拥有大量重载方法。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用对应数据类型的 `getXXXExtra()` 方法

#### 复杂数据类型

##### Bundle数据包

相比`Intent`的方法，`Bundle`支持更多的数据类型，比如`Bundle`自己，或`ArrayList`

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入 `Bundle` 对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getBundleExtra()`方法

##### Serializable

该类必须实现`Serializable`接口，性能相对较差`不推荐`

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getSerializableExtra()`方法，之后强转类型。 

##### Parcelable

该类必须实现`Parcelable`接口，性能相对较好`推荐`

需要重写方法：

- `describeContents()`方法一般使用默认返回0即可
- `writeToParcel(Parcel dest, int flags)` 方法中，我们需要把该类中需要传递的数据保存到 `dest`对象里（序列化）。
- 另外还需要静态Final方法 `Creator<T> CREATOR` ，定义如何反序列化。

`Android Studio`中在类实现了`Parcelable`接口后，光标指向类名按`Alt+Enter`，选择`Add Parcelable Implementation`，即可自动生成如上方法和对应所需的构造方法；如果类成员中包含其他**复杂数据类型**，则会被该操作忽略，除非该类型也实现了`Parcelable`接口。

- 传递：使用`Intent `对象的`putExtra`方法，第二个参数传入对象。
- 接收：`Activity`内直接调用 `getIntent()`方法拿到 `Intent `对象， 调用`getParcelableExtra()`方法，之后强转类型。 

#### Activity的启动方式

1. 父`Activity`中，在`onCreate()`方法中使用如下方法注册一个`ActivityResultLauncher<Intent>`类型的成员变量

   ```java
   launcher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback<ActivityResult>() {
       @Override
       public void onActivityResult(ActivityResult result) {
           // todo 处理响应结果
       }
   });
   ```

   使用该`launcher`对象的`launch`方法启动意图。当然，这里也可以让当前`Activity`直接实现`ActivityResultCallback<ActivityResult>`接口，然后在第二个参数直接传`this`。

2. 在子`Activity`中调用`setResult`方法，可以指定一个`resultCode`(状态码)，和一个 `Intent `对象（用于存放数据）。其中状态码可以使用一些预设的以`Activity.RESULT_`开头的常量，也可以自定义常量。然后调用`finish()`方法结束该`Activity`

3. 在父`Activity`中的`ActivityResult`对象即可使用`getter`获取到状态码和数据

打开系统相册选择图片示例：

```java
private ActivityResultLauncher<Intent> launcher;
private ImageView iv;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_image_pick);
    
    iv = findViewById(R.id.iv);

    launcher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {
        if (result.getResultCode() == RESULT_OK) {
            Intent intent = result.getData();
            if (intent != null) {
                Uri uri = intent.getData();
                // 设置选中的图片给 ImageView
                iv.setImageURI(uri);
            }
        }
    });

    findViewById(R.id.bt_img_pick).setOnClickListener(v -> {
        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_GET_CONTENT);
        intent.setType("image/*");
        launcher.launch(intent);
    });
}
```



# AndroidManifest.xml

## 包含内容

该文件中规定了：

- APP在桌面上显示的图标、名称、主题
- 每一个Activity也可以单独设置图标、名称、主题

## 意图过滤器

注册`Activity`时需要使用`<intent-filter>` 标签配置意图过滤器，按如下配置时表示该`Activity`是APP的主入口

```xml
<intent-filter>
	<action android:name="android.intent.action.MAIN"/>
    <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
```

隐式启动的Activity其category必须为DEFAULT，非入口的Activity一般可配置为

```xml
<intent-filter>
	<action android:name="你的Action"/>
    <category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
```

### Data匹配

`<intent-filter>`标签中可以配置 `<data android:mimeType="xxx" android:scheme="xxx" />` 来配置Data匹配规则，`Intent`中通过 `setData()`对应该规则。

## 元数据

`<activity>`标签中可以设置元数据标签`<meta-data>`，为`Activity`提供数据，元数据标签需要提供`name`、`value`字段。一般作为配置信息

`Activity`类中通过如下方法获取元数据的值：

```java
//获取包管理器
PackageManager packageManager = getPackageManager();
try {
    //获取当前Activity的信息
    ActivityInfo activityInfo = packageManager.getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);
    //元数据包
    Bundle metaData = activityInfo.metaData;
    // 通过name字段获取value字段
    String value = metaData.getString("name");
} catch (PackageManager.NameNotFoundException e) {
    throw new RuntimeException(e);
}
```

### 为APP定义长按图标时弹出的快捷方式列表

1. 在`res`目录下创建`xml`目录，在其中创建一个`shortcuts.xml`文件

2. 在APP的主`Activity`的配置中添加元数据标签，其中`resource`字段指向该文件

   ```xml
   <meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcuts" />
   ```

3. `shortcuts.xml`文件的内容如下(可以使用右键菜单 - NEW - XML - shortcuts XML File 创建模板)：

   ```xml
   <?xml version ="1.0" encoding="utf-8"?>
   <shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
       <shortcut
           android:enabled="true"
           android:shortcutDisabledMessage="@string/launch_disabled"
           android:shortcutId="SHORTCUT_ID"
           android:shortcutLongLabel="@string/launch_exit_long"
           android:shortcutShortLabel="@string/launch_exit_short">
           <intent
               android:action="android.intent.action.VIEW"
               android:targetClass="com.gin.myapp.activity.SecondActivity"
               android:targetPackage="com.gin.myapp.activity" />
       </shortcut>
   </shortcuts>
   ```

4. 这里被启动的`Activity`，其`exported`值必须为true

   

# Drawalbe

`Drawalbe`为抽象类，包括：图片、色块、画板、背景等。所有`Drawable`资源应当放在`res/drawable`目录下

## Shape(形状图形)

- 右键`drawable`目录，选择 New - Drawable Resource File ， 填写文件名，`Root element`选择`shape`，点击`Finish`创建模板文件
- 图形的形状在`<shape>`标签中的`android:shape`字段中选择，默认为矩形
- `<shape>`标签中可以添加若干标签来定义该图形的不同属性：
  1. `<solid>`：填充颜色，`color`颜色
  2. `<stroke>`：描边相关，`color`颜色，`dashGap`每段虚线的间隔，`dashWidth`虚线宽度，`width`描边厚度
  3. `<corners>`：圆角相关，`radius`设置圆角半径，四个角也可以单独设置
  4. `<size>`：尺寸，可以通过`width`和`height`属性设置宽高
  5. `<padding>`：间隔，设置4个方向的间隔
  6. `<gradient>`：渐变

## 点9图

我们可以把一张常规图片转换为点9图，点9图可以通过选定区域，优化图片的拉伸效果

1. 对一张常规图片右键，选择`Create 9-Patch file`
2. 选定区域
   - 上边缘：表示横向拉伸时只拉伸选定区域
   - 左边缘：表示纵向拉伸时只拉伸选定区域
   - 下边缘：表示控件内部文字的横向显示区域
   - 右边缘：表示控件内部文字的纵向显示区域

## 状态列表图形

根据不同状态显示不同的`drawable`

- 右键`drawable`目录，选择 New - Drawable Resource File ， 填写文件名，`Root element`选择`selector`，点击`Finish`创建模板文件
- 在`<selector>`标签中添加若干`<item>`标签，每一个`<item>`标签表示一套状态条件及其匹配的图形，常用属性有：
  - `drawable`：指定图形，必选
  - `state_pressed`：按下状态（Button)
  - `state_checked`：勾选状态（CheckBox、RadioButton）
  - `state_focused`：获得焦点（EditText）
  - `state_selected`：被选中

# 资源文件

## 从资源文件中读取字符串

通过向`Context`类的`getString`方法传递`R.string.xxxx`既可获取到`strings.xml`文件中配置的对应名称的字符串，而`Activity`为`Context`类的子类，因此可以直接调用该方法。

# 布局组件

## LinearLayout(线性布局)

`android:orientation`属性规定了它内部元素的排列方式，`horizontal`(横向,默认值 ),`vertical`(竖向)

### 权重式布局

将线性布局的下级元素的宽高的其中之一设置为`0dp`，并设置`android:layout_weight`权重属性（整数），此时设置为0的那一项的具体数值将根据权重分得最大宽度的一定比例，如2个元素的权重为1和2，则一个占三分之一，一个占三分之二



如果同级元素中有配置了固定宽/高的元素，那么所有配置权重属性的元素将以剩余部分作为最大宽/高；特例：当只有2个元素，一个固定宽/高，一个配置权重时，权重元素将占满剩余部分。

## RelativeLayout(相对布局)

相对布局的下级视图的位置由`参照物`决定，参照物可以是`RelativeLayout`自己，或者下级视图的平级视图

在下级视图上可以配置一系列`android:layout_`开头的属性：

- `layout_centerVertical`、`layout_centerHorizontal`，以及所有名称中带`parent` 的属性，其参照物均为`RelativeLayout`，其他属性均需指定一个参照物视图的id
- `android:layout_align`开头的属性，表示当前视图与参照物视图的特定边界对齐
- `android:layout_toStartOf`表示当前视图的“尾部”与参照物视图的“头部”对齐
- `android:layout_toEndOf`表示当前视图的“头部”与参照物视图的“尾部”对齐

## GridLayout(网格布局)

支持多行多咧表格排列，默认从左往右，从上到下

- `android:columnCount`：列数，当下级视图数量超过该数时，自动换行
- `android:rowCount`：行数

也可以使用权重式布局，但属性名称分为两个：`android:layout_columnWeight`、`android:layout_rowWeight`

## SwipeRefreshLayout(下拉刷新布局)

### 引入依赖

```groovy
implementation "androidx.swiperefreshlayout:swiperefreshlayout:1.1.0"
```

### 使用步骤

- `SwipeRefreshLayout`节点内部仅允许有一个直接子视图，如果存在多个则只显示第一个。且该子视图必须允许滚动（`ScrollView`，`ListView`，`GridView`，`RecyclerView`等）`SwipeRefreshLayout`才支持滚动和下拉刷新

- 使用`setOnRefreshListener`设置刷新监听方法，实现`onRefresh`方法

- 下拉时，`onRefresh`方法被调用，此时布局处于`正在刷新`状态：`isRefreshing`方法返回值为`true`，此时界面顶部有加载动画，且再次下拉不会再次触发`onRefresh`方法调用

- `onRefresh`方法中一般执行耗时操作（网络请求等），耗时操作完成或中断时，应当调用`setRefreshing(false)`方法结束`正在刷新`状态；如果有其他执行刷新操作的途径（比如按钮），也应当使用该方法启动`正在刷新`状态，防止重复操作；或者干脆将刷新操作提取为一个方法，在其中统一修改。

- 设置下拉触发距离，这里设置为100dp

  ```java
  swipeRefreshLayout.setDistanceToTriggerSync((int) (100 * getResources().getDisplayMetrics().density));
  ```

- 

# 视图UI组件

## TextView

### 字体大小

- px：以像素为基准设置字体大小
- dp：根据屏幕大小适配字体大小，相同屏幕大小相同dp的字体占屏幕面积比例相同
- sp：在dp基础上，受到系统字体大小设置的影响（**推荐**）

dp转换为px的方法：

1. 通过`Context`类对象，获取值：`context.getResources().getDisplayMetrics().density`，该值含义为`像素密度`，这里定义为`scale`
2. `(int) (dp * scale + 0.5f)`即为px值（四舍五入）

### 字体颜色

#### Java方式

获取到控件对象之后，使用`setTextColor`方法设置。参数可以：

- 从`Color`类中选择

- `8位16进制数`（使用`0x`开头）
- `6位16进制数`，此时`Alpha`值默认为00，即全透明，因此实际上没有意义。

#### XML方式

在XML标签上使用`android:textColor`属性设置。参数可以使用：

- `8位16进制数`(以`#`开头)

- `6位16进制数`(以`#`开头)，此时`Alpha`值默认为FF，即完全不透明，因此通常可以这样使用
- 使用`@color/xxxx`的格式，引用`colors.xml`资源文件中定义好的颜色

### 背景颜色

#### Java方式

获取到控件对象之后

- 使用`setBackgroudColor`方法设置，参数只能为`Color`类
- 使用`setBackgroundResource`方法设置，参数使用`R.color.xxx`的格式，引用`colors.xml`资源文件中定义好的颜色

#### XML方式

在XML标签上使用`android:background`属性设置。参数使用与字体颜色相同

## View和ViewGroup

- View类是安卓所有UI组件的父类，代表了屏幕上一块空白的矩形区域
- ViewGroup类是View的子类，作为其他UI组件的容器使用。主要作用是为其他组件提供位置分区（排版）

### 视图的宽高

#### XML方式

- 宽：`android:layout_width`，高：`android:layout_height`
- 取值可以为：
  - `match_parent`：与上级视图保持一致
  - `warp_content`：根据内部内容决定大小，但不超过上级视图的尺寸
  - 以dp为单位的具体尺寸

#### Java方式

只有当XML中设置的对应属性为`warp_content`时，才可以使用Java方式修改宽高：

1. 调用控件的`getLayoutParams`方法获取布局参数
2. 修改布局参数的`width`和`height`属性；值为以px为单位的整数。
3. 调用控件的`setLayoutParams`方法，传入修改后的布局参数

### 视图间距

#### XML方式

- `android:layout_margin`：外间距，`android:padding`：内间距
- 表示四个方向均为该值，也可以单独指定某一方向的间距

### 视图对齐方式

#### XML方式

- `android:layout_gravity`属性，设置当前视图对于上级视图的对齐方式
- `android:gravity`属性，设置下级视图对当前视图的对齐方式
- 取值可以用`|`表示“且”逻辑

## ScrollView和HorizontalScrollView(滚动视图)

- ScrollView为纵向滚动，`android:layout_height`属性应当设置为`warp_content`
- HorizontalScrollView为横向滚动，`android:layout_width`属性应当设置为`warp_content`

##  Button(按钮)

继承于`TextView`，默认配置了背景颜色，文字居中，并将英文全部转换为大写。

- `android:textAllCaps`：设置为false关闭自动大写

### 点击事件

通过`setOnClickListener`方法绑定事件，需要提供一个`View.OnClickListener`接口，可以使用匿名内部类、lambda、或自定义一个类对其进行实现，如果使用具名内部类应使用静态内部类。

或也可以让当前类实现`View.OnClickListener`接口，`setOnClickListener`方法传`this`，目的为让本视图内的所有点击事件均走同一如空，并通过`onClick(View view)`方法的参数判断点击的是哪一个控件，进而执行不同的逻辑

### 长按事件

长按时间超过500ms的为长按

通过`setOnLongClickListener`方法，提供`View.OnLongClickListener`接口来实现。其中`onLongClick`需要返回一个`boolean`，表示是否消耗该事件，如果不消耗则也会触发`点击事件`，并且会触发上级视图的长按事件。

### 可用状态

XML通过`android:enabled`属性设置按钮的可用性，JAVA使用`setEnabled`方法

##  ImageView(图片)

`ImageView`类是 `View`类的子类，可以在界面上显示图片（Drawable)。

### 图片地址

`android:src`属性指定了图片地址，值可以`@drawable/xxx`格式显示`drwaable`资源目录下的图片（包括常规图片和xml矢量图）

JAVA中使用`setImageResource`方法设置

### 适应策略

`android:scaleType`属性（适应策略）：

- `fitXY`：缩放图片，使之充满ImageView，图片的宽高比可能会改变。
- `fitStart`：保持宽高比缩放，直至能完全显示。并显示在ImageView左上角。
- `fitCenter`：(默认值)同上，区别是最终显示位置在中央。
- `fitEnd`：同上，区别是最终显示位置在右下角
- `center`：不进行缩放，放在ImageView的中间
- `centerCrop`：保持宽高比缩放，放在ImageView的中间，直至图片能完全覆盖ImageView
- `centerInside`：保持宽高比缩放，放在ImageView的中间，直至ImageView完全显示图片

JAVA中使用`setScaleType`方法设置，参数为枚举类型

## ImageButton(图片按钮)

`ImageButton`继承自`ImageView`

- 只能显示图片不能显示文本
- 图像可按比例缩放
- 可设置前景+背景，实现叠加显示。
- 默认适应策略为`center`

## 同时显示文本+图像的方案

1. 使用`LinearLayout`（或其他布局），将`TextView`和`ImageView`组合为一个控件
2. 设置`Button`控件的`drawable****`属性设置图标

## CheckBox(复选框)

XML

- `text`：复选框后的文字
- `checked`：是否选中（初始值）
- `button`：提供一个`drawable`（一般应该为`selector`）替换复选框图标

Java：

- `setOnCheckedChangeListener`：指定当勾选状态改变时执行的回调方法
- `setChecked`：设置勾选状态
- `setButtonDrawable`：设置复选框图标

## Switch(开关)

`Android Studio`会推荐使用`SwitchCompat`类

XML：

- `text`：开关左侧文本
- `track`：设置开关轨道背景，可以通过设置一个`selector`，配置`state_checked`属性来模仿IOS风格开关

Java：

- `setText`：设置左侧文本
- `setOnCheckedChangeListener`：指定当勾选状态改变时执行的回调方法
- `setChecked`：设置勾选状态

## Radio(单选框)

实际使用的是`RadioGroup`（单选框组）和`RadioButton`（单选框）类，`RadioGroup`中可以放若干个`RadioButton`，代表它们属于同一组，同一组中的单选框只能被选中一个。每一个`RadioButton`均必须设置ID，回调方法时会用到

XML：

- `orientation`：指定单选框的排列方向，默认垂直

Java：

- `RadioGroup`上使用`setOnCheckedChangeListener`绑定勾选状态改变的回调方法，将会返回当前被选中的`RadioButton`的id

## EditText(文本输入框)

XML

- `hint`：占位提示，相当于HTML的placeholder
- `inputType`：输入类型，常用值：文本，密码，数字密码，整数，小数，带符号整数等
- `maxLength`：最大输入长度

Java

- `setOnFocusChangeListener`：设置焦点状态的变更监听
- `addTextChangedListener`：设置文本变化的监听

## AlertDialog(提醒框)

一个包含标题，正文，肯定、否定、(中性)按钮的简单提示框

使用范例：

```java
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle("标题");
builder.setMessage("正文");
builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        Log.i(TAG, "onClick: 确定");
    }
});

builder.setNegativeButton("取消", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        Log.i(TAG, "onClick: 取消");
    }
});
AlertDialog alertDialog = builder.create();
alertDialog.show();
```

## DatePickerDialog(日期选择弹窗)

使用范例：

```java
ZonedDateTime zdt = ZonedDateTime.now();
DatePickerDialog datePickerDialog = new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() {
    @Override
    public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
        Log.i(TAG, String.format("%d %d %d", year, month + 1, dayOfMonth));
    }
}, zdt.getYear(), zdt.getMonthValue() - 1, zdt.getDayOfMonth());
datePickerDialog.show();
```

简化处理类，参数使用`ZonedDateTime`：

```java
/**
 * 自定义日期选择弹窗
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/3 11:43
 **/
public class MyDatePickerDialog {
    DatePickerDialog dialog;

    public MyDatePickerDialog(Context context,OnDateSetListener listener) {
        this.dialog = new DatePickerDialog(context,
                listener,
                listener.zdt.getYear(),
                listener.zdt.getMonthValue()-1,
                listener.zdt.getDayOfMonth());
    }

    public static abstract class OnDateSetListener implements DatePickerDialog.OnDateSetListener {
        final ZonedDateTime zdt;

        public OnDateSetListener(ZonedDateTime zdt) {
            this.zdt = zdt;
        }

        public OnDateSetListener() {
            this(ZonedDateTime.now());
        }

        @Override
        public final void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
            onDateSet(view,zdt.withYear(year).withMonth(month+1).withDayOfMonth(dayOfMonth));
        }

        protected abstract void onDateSet(DatePicker view, ZonedDateTime zonedDateTime);
    }
}
```

## Spinner(下拉框选择)

   XML

- `spinnerMode`：配置下拉框是常规模式(`dropdown`)还是弹窗模式(`dialog`)

示例：

```java
public static final String TAG = "SPINNER";
public static final String[] OPTIONS = new String[]{"AA", "BB", "CC", "DD"};
private Spinner spinner;
private ArrayAdapter<String> arrayAdapter;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_spinner);

    spinner = findViewById(R.id.sp_dropdown);
    // 创建适配器 ，布局文件 R.layout.item_spinner 中仅有一个 TextView
    arrayAdapter = new ArrayAdapter<>(this, R.layout.item_spinner, OPTIONS);
    // 设置适配器
    spinner.setAdapter(arrayAdapter);
    // 设置弹窗标题(仅dialog模式)
    spinner.setPrompt("弹窗标题");
    // 默认选中第一个
    spinner.setSelection(0);
    // 选项变更的监听
    spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            if (parent.getId() == R.id.sp_dropdown) {
                Log.i(TAG, "onItemClick: p:" + position + " id:" + id);
            } else {
                Log.i(TAG, "onItemClick: ??");
            }
            Log.i(TAG, "onItemClick: " + parent.getClass());
            Log.i(TAG, "onItemClick: " + view.getClass());
        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {
            Log.i(TAG, "onItemClick: " + parent.getClass());
        }
    });
}
```

## ListView(列表)

XML：

`layout_height`属性需设置为`wrap_content`

列表条目的根组件上配置属性`android:descendantFocusability="blocksDescendants"`，可避免下级元素获得焦点，影响条目的点击事件触发

JAVA：

使用适配器插入数据即可

## GridView(网格)

| XML属性           | JAVA设置方法         | 说明                   |
| ----------------- | -------------------- | ---------------------- |
| horizontalSpacing | setHorizontalSpacing | 网格项在水平方向的间距 |
| verticalSpacing   | setVerticalSpacing   | 网格项在垂直方向的间距 |
| numColumns        | setNumColumns        | 列数                   |
| stretchMode       | setStretchMode       | 拉伸模式               |
| columnWidth       | setColumnWidth       | 列宽                   |

拉伸模式可选：

| XML                 | JAVA                    | 说明                                               |
| ------------------- | ----------------------- | -------------------------------------------------- |
| none                | NO_STRETCH              | 不拉伸，按对齐方向排列                             |
| columnWidth(默认)   | STRETCH_COLUMN_WIDTH    | 如果有剩余空间，拉伸列宽填充                       |
| spacingWidth        | STRETCH_SPACING         | 如果有剩余空间，把剩余空间放入列间空隙             |
| spacingWidthUniform | STRETCH_SPACING_UNIFORM | 如果有剩余空间，列宽拉伸但内容不拉伸，内容居中显示 |



## TableLayout(表格布局)

`todo`

## PopupWindow(弹窗)

`todo`

## DrawerLayout(侧滑菜单)

`todo`

## SeekBar滑块组件

thumb属性可以指定一个Drawable对象，作为滑块；max属性可以指定最大值，不能指定最小值。  

## ProgressBar进度条组件

属性：

- max：最大值
- progress：当前进度

样式：

- progressBarStyle：转圈形式，无法看到实际进度
- progressBarStyleSmall：小转圈形式
- progressBarStyleLarge：大转圈形式
- progressBarStyleHorizontal：常规水平进度条形式

## TabLayout

标签导航组件，通常与`ViewPage2`配合，可以直接放到`Toolbar`中，也可以自己单独占一行。

与`ViewPage2`关联之后，二者的翻页操作将双向绑定：

```java
new TabLayoutMediator(tabLayout, vp2, (tab, position) -> {
    // 根据位置配置每个标签
    if (position == 0) {
        tab.setText(R.string.navi_text_home);
    }
    if (position == 1) {
        tab.setText(R.string.navi_text_me);
    }
    if (position == 2) {
        tab.setText(R.string.navi_text_notice);
    }
}).attach();
```

# SharedPreferences(共享参数)

用于存储简单数据，使用键值对方式存储到私有目录的`shared_prefs/xxxx.xml`文件中，可以保存的类型为：`int`、`float`、`boolean`、`String`、`Long`、`Set<String>`

使用范例：

```java
// 获取 SharedPreferences对象
SharedPreferences sharedPreferences = getSharedPreferences("filename", Context.MODE_PRIVATE);
// 读取
String string = sharedPreferences.getString("key", "defaultValue");
// 修改
SharedPreferences.Editor editor = sharedPreferences.edit();
editor.putString("key", "value");
editor.putString("key2", "value");
// 修改完毕后需要调用 apply 或 commit进行提交，apply为异步写入，推荐
editor.apply();
editor.commit();
```

# DataStore

共享参数会在初始化时把整个文件加载进内存，当数据量较大时可能导致主进程阻塞，因此建议使用`DataStore`

## 添加依赖

```groovy
implementation 'androidx.datastore:datastore-preferences:1.0.0'
implementation 'androidx.datastore:datastore-preferences-rxjava3:1.0.0'
```

## 初始化

和`SharedPreferences`基本一致，需要一个上下文和一个名字

```java
 RxDataStore<Preferences> dataStore = new RxPreferenceDataStoreBuilder(context, name).build()
```

## 读写

读写都需要将字符串key转换为`Preferences.Key<T>`，其中`T`为值的类型。`Preferences.Key<T>`通过`PreferencesKeys.xxxxKey(String key)`方法生成

读：

```java
dataStore.data().map(r -> r.get(PreferencesKeys.xxxxKey(key)).blockingFirst()
```

写：

```
dataStore.updateDataAsync(preferences -> {
    MutablePreferences mutablePreferences = preferences.toMutablePreferences();
    mutablePreferences.set(PreferencesKeys.xxxxKey(key), value);
    return Single.just(mutablePreferences);
});
```

## 工具类

单例模式，自动匹配值类型

```java
/**
 * DataStore工具类
 *
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/11 15:05
 **/
public class DataStoreUtils {
    public static final String DEFAULT_NAME = "datastore";
    private static final HashMap<String, DataStoreUtils> DATA_STORE_MAP = new HashMap<>();
    @NonNull
    private final RxDataStore<Preferences> dataStore;

    private DataStoreUtils(Context context, String name) {
        this.dataStore = new RxPreferenceDataStoreBuilder(context, name).build();
    }

    /**
     * 单例模式，默认名称
     *
     * @return 工具对象
     */
    public static DataStoreUtils getInstance() {
        return getInstance(null);
    }

    /**
     * 单例模式，默认名称
     *
     * @param context 上下文
     * @return 工具对象
     */
    public static DataStoreUtils getInstance(Context context) {
        return getInstance(context, DEFAULT_NAME);
    }

    /**
     * 单例模式
     *
     * @param context 上下文
     * @param name    dataStore名称
     * @return 工具对象
     */
    public static DataStoreUtils getInstance(Context context, String name) {
        if (!DATA_STORE_MAP.containsKey(name) && context != null) {
            DATA_STORE_MAP.put(name, new DataStoreUtils(context, name));
        }
        return DATA_STORE_MAP.get(name);
    }

    /**
     * 根据value值的类型返回 Preferences.Key
     *
     * @param key   key
     * @param value value
     * @param <T>   值类型
     * @return {@link Preferences.Key}
     */
    @SuppressWarnings("unchecked")
    private static <T> Preferences.Key<T> getPreferencesKey(String key, @NonNull T value) {
        if (value instanceof String) {
            return (Preferences.Key<T>) PreferencesKeys.stringKey(key);
        }
        if (value instanceof Integer) {
            return (Preferences.Key<T>) PreferencesKeys.intKey(key);
        }
        if (value instanceof Long) {
            return (Preferences.Key<T>) PreferencesKeys.intKey(key);
        }
        if (value instanceof Float) {
            return (Preferences.Key<T>) PreferencesKeys.floatKey(key);
        }
        if (value instanceof Double) {
            return (Preferences.Key<T>) PreferencesKeys.doubleKey(key);
        }
        if (value instanceof Boolean) {
            return (Preferences.Key<T>) PreferencesKeys.booleanKey(key);
        }
        if (value instanceof Set) {
            return (Preferences.Key<T>) PreferencesKeys.stringSetKey(key);
        }
        throw new RuntimeException("不支持的类型:" + value.getClass());
    }

    /**
     * 获取值
     *
     * @param key          key
     * @param defaultValue 默认值
     * @param <T>          值类型
     * @return 值
     */
    public <T> T get(String key, @NonNull T defaultValue) {
        try {
            return dataStore.data().map(r -> r.get(getPreferencesKey(key, defaultValue))).blockingFirst();
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 设置值
     *
     * @param key   key
     * @param value value
     * @param <T>   值类型
     * @return 结果
     */
    public <T> Single<Preferences> set(String key, @NonNull T value) {
        return dataStore.updateDataAsync(preferences -> {
            MutablePreferences mutablePreferences = preferences.toMutablePreferences();
            mutablePreferences.set(getPreferencesKey(key, value), value);
            return Single.just(mutablePreferences);
        });
    }
}
```

使用：

```java
DataStoreUtils dataStoreUtils = DataStoreUtils.getInstance(this);

System.out.println(dataStoreUtils.get(key, -1L));

dataStoreUtils.set(key, System.currentTimeMillis());
```

# SqlLite

轻量单文件SQL数据库，可以指定任意路径保存，一般保存在`getFilesDir()`目录下

创建：

```java
SQLiteDatabase database = openOrCreateDatabase("filepath", Context.MODE_PRIVATE, null);
```

删除：

```java
deleteDatabase("文件路径.db")
```

## SQLLiteOpenHelper

通常使用该类对数据库进行管理

使用范例：

```java
/**
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/3 15:51
 **/
public class MyDBHelper extends SQLiteOpenHelper {
    private static final String NAME = "test.db";
    private static final int VERSION = 1;
    private static MyDBHelper dbHelper;
    private SQLiteDatabase readConnection;
    private SQLiteDatabase writeConnection;

    private MyDBHelper(Context context) {
        super(context, NAME, null, VERSION);
    }

    /**
     * 单例模式
     *
     * @return
     */
    public static MyDBHelper getInstance(Context context) {
        if (dbHelper == null) {
            dbHelper = new MyDBHelper(context);
        }
        return dbHelper;
    }

    /**
     * 获取读连接
     *
     * @return 读连接
     */
    public SQLiteDatabase getReadConnection() {
        if (this.readConnection == null || !this.readConnection.isOpen()) {
            this.readConnection = dbHelper.getReadableDatabase();
        }
        return this.readConnection;
    }

    /**
     * 获取写连接
     *
     * @return 写连接
     */
    public SQLiteDatabase getWriteConnection() {
        if (this.writeConnection == null || !this.writeConnection.isOpen()) {
            this.writeConnection = dbHelper.getWritableDatabase();
        }
        return this.writeConnection;
    }

    /**
     * 关闭所有连接
     */
    public void closeConnections() {
        if (this.readConnection != null && this.readConnection.isOpen()) {
            this.readConnection.close();
            this.readConnection = null;
        }
        if (this.writeConnection != null && this.writeConnection.isOpen()) {
            this.writeConnection.close();
            this.writeConnection = null;
        }
    }


    @Override
    public void onCreate(SQLiteDatabase db) {
        // todo 创建数据库时执行的操作（一般为建表操作）
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // todo 更新数据库版本时执行的操作（更新数据结构）
    }

    /**
     * 插入操作
     *
     * @param tableName 表名
     * @param values    对线值map
     * @return 行号，-1表示插入失败
     */
    public long insert(String tableName, ContentValues values) {
        return getWriteConnection().insert(tableName, null, values);
    }
}
```

## Jetpack-Room

参考：https://blog.csdn.net/zhuowalun8427/article/details/127703090

### 引入依赖

```groovy
implementation "androidx.room:room-runtime:2.5.2"
annotationProcessor "androidx.room:room-compiler:2.5.2"
```

### 使用步骤

1. 在实体类上使用`@Entity`注解，注解上可以配置：表名、索引、主键、外键、忽略的字段，不配置表名则使用类名
   1. 在主键（一般为id列）上使用`@PrimaryKey(autoGenerate = true)`注解
   2. 在其他列上可以使用`@ColumnInfo`注解配置列名、是否建立索引、默认值；不使用则列名使用字段名
   2. 需要忽略的字段使用`@Ignore`注解
   2. 如果配置了多个构造函数，必须使用`@Ignore`注解标记不希望`Room`使用的构造函数，一般来说应该标记所有的有参构造
2. 创建接口`XXXDao`类，使用`@Dao`注解
   1. 插入/删除/修改方法的定义：参数使用对应的实体类，可以使用泛型集合，可以使用可变参数；根据操作类型在方法上使用注解：`@Insert`/`@Delete`/`@Update`
   2. 查询方法的定义：在方法上使用注解`@Query`，返回类型使用对应的实体类或泛型为实体类的列表，注解参数填写查询SQL语句
      - 实体类名即为表名
      - SQL语句中使用`:xxx`的方式引用方法的参数
   3. `@Query`注解实际上代表执行自定义的任意SQL语句，即也可以写其他类型的操作，插件会自动提示表名列名等信息
   3. `@Insert`可以配置属性`onConflict`，表示遇到重复时的策略，可以配置为`OnConflictStrategy`类下的常量
3. 创建数据库抽象类`MyDatabase`，继承`RoomDatabase`类
   1. 类上使用注解`@Database`，entities属性填写所有的实体类，version属性填写版本，exportSchema设置为false
   2. 该类中提供抽象方法返回`XXXDao`对象
4. 在自定义`Application`中创建数据库对象
   1. `Room.databaseBuilder(this,MyDatabase.class,数据库名称).allowMainThreadQueries().build()`
   2. 一般来说不允许在主线程创建数据库
5. 对项目进行`build`操作时，插件将在build目录中生成如下实现类：`@Dao`,`@Database`，操作完成后可以在对应类上看到实现类提示

### 使用范例

实体类

```java
@Entity
public class NgaAccount {
    /**
     * 主键id
     */
    @PrimaryKey(autoGenerate = true)
    public Long id;
    /**
     * 用户id
     */
    public long userId;
    /**
     * 用户名
     */
    public String username;
    /**
     * cookie
     */
    public String cookie;

    /**
     * 不希望被Room使用的构造函数使用@Ignore标记
     *
     * @param userId   用户id
     * @param username 用户名
     * @param cookie   cookie
     */
    @Ignore
    public NgaAccount(long userId, String username, String cookie) {
        this.userId = userId;
        this.username = username;
        this.cookie = cookie;
    }

    public NgaAccount() {
    }
}
```

Dao

```java
@Dao
public interface NgaAccountDao {
    @Query("SELECT * FROM NgaAccount")
    List<NgaAccount> listAll();

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void add(NgaAccount user);

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void add(List<NgaAccount> list);

    @Delete
    int delete(NgaAccount user);

    @Update
    int update(NgaAccount user);
}
```

数据库类

```java
@Database(entities = {NgaAccount.class}, version = 1, exportSchema = false)
public abstract class NgaDatabase extends RoomDatabase {
    public abstract NgaAccountDao ngaAccountDao();
}
```

MainApplication

```java
public class MainApplication extends Application {
    public static MainApplication instance;
    public NgaDatabase ngaDatabase;

    @Override
    public void onCreate() {
        super.onCreate();
        instance = this;
        ngaDatabase = Room.databaseBuilder(this, NgaDatabase.class, "nga_database")
                .addMigrations()
                .allowMainThreadQueries()
                .build();
    }
}
```

使用

```java
NgaDatabase database = MainApplication.instance.ngaDatabase;
NgaAccountDao ngaAccountDao = database.ngaAccountDao();
List<NgaAccount> ngaAccounts = ngaAccountDao.listAll();
System.out.println("现有账号: " + ngaAccounts.size() + " 个");
```

## GreenDao

### 引入依赖

参考资料：https://blog.csdn.net/Cupster/article/details/114267141

`setttings.gradle`中配置仓库信息

```groovy
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        mavenLocal();
        maven { url 'https://maven.aliyun.com/repository/google' }
        //central和jcenter的聚合仓库
        maven { url 'https://maven.aliyun.com/repository/public' }
        //仅顶级build.gradle需配置插件仓库
        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
        google()
        mavenCentral()
    }
}
```

在项目的`build.gradle`中配置插件信息

```groovy
buildscript {
    dependencies {
        classpath 'com.android.tools.build:gradle:7.1.2'
        classpath 'org.greenrobot:greendao-gradle-plugin:3.3.0'
    }
}
```

快捷键`CTRL+ALT+SHIFT+S`，将`Project - Gradle Version`修改为`7.6.2`，确定，等待同步。这里如果选择8以上版本会报错：

```
A problem occurred configuring project ':app'.
> Could not create task ':app:greendaoPrepare'.
   > Cannot use @TaskAction annotation on method DetectEntityCandidatesTask.execute() because interface org.gradle.api.tasks.incremental.IncrementalTaskInputs is not a valid parameter to an action method.
```

在模块的`build.gradle`中

在`plugins`节点中添加

```groovy
id 'org.greenrobot.greendao'
```

在`android`节点中添加

```groovy
greendao {
    schemaVersion 1 //数据库版本号
    daoPackage 'com.gin.myapp.greendao'// 设置DaoMaster、DaoSession、Dao 包名
    targetGenDir 'src/main/java'//设置DaoMaster、DaoSession、Dao目录
}
```

在`dependencies`节点中添加

```groovy
implementation 'org.greenrobot:greendao:3.3.0'
```

### 使用步骤

1. 编写实体类

   1. 在实体类上使用`@Entity`注解
   2. 对非空字段使用`@org.greenrobot.greendao.annotation.NotNull`注解
   3. 对主键使用`@org.greenrobot.greendao.annotation.Id`注解

2. 编译项目，插件会为实体类添加构造方法、getter/setter方法，并在`greendao`节点中配置的路径下自动生成：

   1. `DaoMaster`类（数据库对象）
   2. `DaoSession`类（会话对象）
   3. 若干`xxxxDao`类，其中xxx为实体类名

3. 编写Dao管理类（相当于数据库管理）

   1. 对实体类的操作最终由`xxxDao`类执行

   2. `xxxDao`对象通过`DaoSession`对象获取，而`DaoSession`对象通过`DaoMaster`对象的`newSession`方法获取

   3. 参考代码如下

      ```java
      public class DaoManager {
          public static final String DB_NAME = "nga_greendao_database";
          private static DaoManager MANAGER;
          private DaoMaster.DevOpenHelper openHelper;
          private DaoMaster daoMaster;
          private DaoSession daoSession;
      
          private DaoManager(Context context) {
              init(context);
          }
      
          /**
           * 单例模式
           *
           * @param context
           * @return DaoManager
           */
          public static DaoManager getInstance(Context context) {
              if (MANAGER == null) {
                  MANAGER = new DaoManager(context);
              }
              return MANAGER;
          }
      
          /**
           * 初始化
           *
           * @param context 上下文
           */
          public void init(Context context) {
              this.openHelper = new DaoMaster.DevOpenHelper(context, DB_NAME, null);
              this.daoMaster = new DaoMaster(this.openHelper.getWritableDb());
          }
      
          /**
           * 获取连接
           *
           * @return DaoSession
           */
          public DaoSession getDaoSession() {
              if (daoSession == null) {
                  this.daoSession = daoMaster.newSession();
              }
              return daoSession;
          }
      
          /**
           * 关闭连接
           */
          public void close() {
              if (this.daoSession != null) {
                  this.daoSession.clear();
                  this.daoSession = null;
              }
              if (this.openHelper != null) {
                  this.openHelper.close();
                  this.openHelper = null;
                  this.daoMaster = null;
              }
          }
      }
      ```

4. 从`DaoManager`获取实体类Dao之后按参考资料操作即可

## DBFlow

https://cupster.blog.csdn.net/article/details/114592859

# 外部存储

## 外部私有空间

通过`getExternalFilesDirs(Environment.DIRECTORY_xxxxxxxxxx)`方法获取外部存储的路径，然后直接使用JAVA常规文件操作即可

## 外部公共空间

通过`Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_xxxxxx)`方法获取外部存储的路径，然后直接使用JAVA常规文件操作即可

在`AndroidManifest.xml`中：

1. `<application>`标签需要添加属性`android:requestLegacyExternalStorage="true"`
2. 对于低版本SDK需要申请权限

```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
```

# 读写图片文件

## 读取和显示

使用`BitmapFactory.decodeXXXX`方法从不同来源读取图片，常用的有：

- `decodeResource`：从资源文件中读取，第一个参数可以直接传`getResources()`
- `decodeFile`：从文件中读取
- `decodeStream`：从流中读取

使用`ImageView`的`setImageBitmap`显示`Bitmap`图片；或`setImageURI(Uri.parse(文件路径))`直接显示图片

## 保存图片文件

使用`Bitmap`对象的`compress`方法保存图片为文件（或用流输出）

## 回收

`Bitmap`对象使用完毕之后需要调用`recycle()`方法回收内存。

# Application

应用对象，每个APP只有一个`Application`对象，其生命周期贯穿整个APP的运行过程。可以在其中存储一些全局变量。

适合存储的变量类型大致为：

- 会频繁读取的信息
- 不方便由意图传递的信息（位图对象，非字符串类型的集合对象等）
- 容易因频繁分配内存导致内存泄露的对象，如`Handler`

# ContentProvider(内容提供者)

用于应用之间的数据共享

## Server端

右键 New - Ohter - Content Provider，其中`URI Authorities`项先填“xxx”。创建完成后`AndroidManifest.xml`文件中会多出一项`<provider>`的配置，将其中的`authorities`属性修改为刚刚创建的Provider的完整类名。



Provider类中已经默认实现了必须的增删改查方法，在其中实现自己的业务逻辑即可。

## Client端

通过`getContentResolver()`方法获得`ContentResolver`对象，该对象中即有对应Provider的增删改查方法，这些方法均需要提供一个URI，该URI的构建格式为：`content://{authorities}/{路径}`，通过`Uri.parse`方法将该字符串解析为`Uri`对象



在`AndroidManifest.xml`中配置

```xml
<queries>
    <package android:name="server端包名"/>
    <!--        或-->
    <provider android:authorities="server端的authorities属性"/>
</queries>
```

## 在URI路径部分传参/规定URI路径

在Provider类中增加如下代码定义，其中`AUTHORITY`为`authorities`属性值，静态块中表示当前两个参数与给定的URI匹配时，返回第三个参数（状态码）。其中`#`表示参数占位符

```java
private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
private static final String AUTHORITY = "com.gin.myapp.activity.activity.MyContentProvider";

static {
    URI_MATCHER.addURI(AUTHORITY, "/user", 200);
    URI_MATCHER.addURI(AUTHORITY, "/user/#", 201);
}
```

然后在业务逻辑中，这样区分不同的路径

```java
switch (URI_MATCHER.match(uri)){
    case 200:break;
    case 201:break;
}
```

# 权限动态请求

部分权限不仅需要在`AndroidManifest.xml`中配置，也需要在使用时向用户请求批准使用

## AndroidManifest.xml配置

示例，申请收发短信权限

```xml
<uses-feature
    android:name="android.hardware.telephony"
    android:required="false" />
<uses-permission android:name="android.permission.READ_SMS"/>
<uses-permission android:name="android.permission.SEND_SMS"/>
<uses-permission android:name="android.permission.READ_CONTACTS" />
<uses-permission android:name="android.permission.WRITE_CONTACTS" />
```

## 动态请求范例

工具类方法：检查当前是否持有给定的所有权限，如果不全持有则弹窗请求授权

```java
public class PermissionUtils {
    /**
     * 检查是否持有给定的所有权限，如果有任一未持有则弹窗请求授权
     *
     * @param activityCompat {@link AppCompatActivity}
     * @param requestCode    请求code
     * @param permissions    权限
     * @return 当前是否持有所有权限
     */
    public static boolean checkPermissions(AppCompatActivity activityCompat, int requestCode, String... permissions) {
        if (permissions == null) {
            return false;
        }
        if (!hasPermissions(activityCompat, permissions)) {
            activityCompat.requestPermissions(permissions, requestCode);
            return false;
        }
        return true;
    }

    /**
     * 判断当前是否持有给定的所有权限
     *
     * @param activityCompat {@link AppCompatActivity}
     * @param permissions    权限
     * @return 是否持有所有权限
     */
    public static boolean hasPermissions(AppCompatActivity activityCompat, String... permissions) {
        if (permissions == null) {
            return false;
        }
        for (String permission : permissions) {
            if (activityCompat.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }
    /**
     * 判断授权结果是否为全部授权
     *
     * @param grantResults 授权结果
     * @return 判断授权结果是否为全部授权
     */
    public static boolean hasPermissions(@NonNull int[] grantResults) {
        for (int grantResult : grantResults) {
            if (grantResult != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }
}
```

Activity中使用：

```java
public static final String TAG = "PermissionActivity";

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_permission);


    findViewById(R.id.permission_sms).setOnClickListener(this);
    findViewById(R.id.permission_contact).setOnClickListener(this);
}

@Override
public void onClick(View v) {
    int id = v.getId();
    if (id == R.id.permission_sms) {
        if (PermissionUtils.checkPermissions(this, 200
                                             , Manifest.permission.READ_SMS, Manifest.permission.SEND_SMS)) {
            //todo 持有权限，执行业务逻辑
            Log.i(TAG, "onClick: 持有短信权限");
        }
    } else if (id == R.id.permission_contact) {
        if (PermissionUtils.checkPermissions(this, 300
                                             , Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS)) {
            //todo 持有权限，执行业务逻辑
            Log.i(TAG, "onClick: 持有联系人权限");
        }
    }
}


/**
     * 请求授权的结果回调
     */
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    if (PermissionUtils.hasPermissions(grantResults)) {
        Log.i(TAG, "onRequestPermissionsResult: 授权成功 code: " + requestCode);
        // todo 执行业务逻辑
    } else {
        Log.i(TAG, "onRequestPermissionsResult: 授权失败 code: " + requestCode);
        jumpToSettings();
    }
}

/**
     * 授权失败，跳转到设置界面
     */
private void jumpToSettings() {
    Intent intent = new Intent();
    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
    intent.setData(Uri.fromParts("package", getPackageName(), null));
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);
}
```

## 常用权限(常量)

以下常量均以`Manifest.permission`开头

| 名称                   | 说明       |
| ---------------------- | ---------- |
| READ_EXTERNAL_STORAGE  | 读存储卡   |
| WRITE_EXTERNAL_STORAGE | 写存储卡   |
| READ_CONTACTS          | 读联系人   |
| WRITE_CONTACTS         | 写联系人   |
| SEND_SMS               | 发短信     |
| RECEIVE_SMS            | 接收短信   |
| READ_SMS               | 读短信     |
| READ_CALL_LOG          | 读通话记录 |
| WRITE_CALL_LOG         | 写通话记录 |
| CAMERA                 | 相机       |
| RECORD_AUDIO           | 录音       |
| ACCESS_FINE_LOCATION   | 精确定位   |



# Adapter(适配器)

## SimpleAdapter

构造方法：

```java
new SimpleAdapter(Context context, List<? extends Map<String, ?>> data,
            @LayoutRes int resource, String[] from, @IdRes int[] to)
```

- Context ：直接传 this （当前Activity）
- data：一个成员为`Map<String,?>`的List，即数据源。一个Map对应列表一行
- resource：用于渲染列表的一行的xml布局文件的id，布局文件中接收数据的组件支持：`ImageView`，`TextView`，继承或实现`Checkable`接口的组件(典型的如：单选框、复选框)

- from：包含Map中的所有key的数组
- to：布局文件中所有需要显示数据的组件的id
- （from 和 to 中的值会按照给出的顺序进行映射） 

## BaseAdapter

当布局格式更复杂时，需要自行定义专用的适配器，实现示例：

```java
/**
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/5 11:48
 **/
public class MyAdapter extends BaseAdapter {
    /**
     * 上下文
     */
    private final Context context;
    /**
     * 数据
     */
    private final List<Object> data;

    public MyAdapter(Context context, List<Object> data) {
        this.context = context;
        this.data = data;
    }

    /**
     * @return 数据条数
     */
    @Override
    public int getCount() {
        return data.size();
    }

    /**
     * @param position 位置
     * @return 指定位置上的数据
     */
    @Override
    public Object getItem(int position) {
        return null;
    }

    /**
     * @param position 位置
     * @return 指定位置上的元素id
     */
    @Override
    public long getItemId(int position) {
        // 不重复即可
        return position;
    }

    /**
     * 返回需要显示的组件
     * @param position    位置
     * @param convertView 当组件元素移出屏幕时将被回收重用
     * @param parent      父组件
     * @return 组件
     */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        if (convertView == null) {
            // 当不是重用时，构造一个新的组件
            convertView = LayoutInflater.from(context).inflate(R.layout.item_spinner, parent, false);
            // 从组件中拿到各组件，放到 ViewHolder 中
            viewHolder = new ViewHolder();
            viewHolder.tv = convertView.findViewById(R.id.iv);
            // 把viewHolder保存到组件中
            convertView.setTag(convertView);
        } else {
            // 当是重用时取出 viewHolder
            viewHolder = (ViewHolder) convertView.getTag();
        }

        // 使用该位置的数据，修改组件中的属性
        Object obj = data.get(position);
        viewHolder.tv.setText(obj.toString());
        //返回组件
        return convertView;
    }

    /**
     * 保存布局文件中需要被操作的组件
     */
    public static class ViewHolder {
        TextView tv;
    }
}
```

## RecyclerView(循环视图)

相当于增强版的`ListView`+`GridView`，同时还支持瀑布流布局，通过设置布局管理器`LayoutManager`实现。

### 适配器

`RecyclerView`使用的适配器`RecyclerView.Adapter`内部已实现了上述的ViewHolder式重用逻辑，使用时只需要关注内部组件的初始化和数据添加即可

示例：

```java
public class TopicRecyclerAdapter extends RecyclerView.Adapter<TopicRecyclerAdapter.TopicViewHolder> {

    private List<String> data;

    /**
     * 将需要渲染的数据传入
     *
     * @param data    数据
     */
    public TopicRecyclerAdapter(List<String> data) {
        this.data = data;
    }

    /**
     * 创建每个内部组件的 ViewHolder
     */
    @NonNull
    @Override
    public TopicViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // 从布局文件中加载视图
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_spinner, parent, false);
        // 创建ViewHolder
        return new TopicViewHolder(view);
    }

    /**
     * 将指定位置的数据填充到视图组件中
     */
    @Override
    public void onBindViewHolder(@NonNull TopicViewHolder holder, int position) {
        String s = data.get(position);
        holder.tv.setText(s);
    }

    @Override
    public int getItemCount() {
        return data==null?0:data.size();
    }

    /**
     * ViewHolder类
     */
    public static class TopicViewHolder extends RecyclerView.ViewHolder {
        TextView tv;

        public TopicViewHolder(@NonNull View itemView) {
            super(itemView);
            // 使用 findViewById 拿到每个需要进行操作的控件
            tv = itemView.findViewById(R.id.text_notifications);
        }
    }
}
```

### LayoutManager(布局管理器)

- `LinearLayoutManager`：线性布局，可以选择横向或纵向，是否倒序
- `GridLayoutManager`：网格布局，可以设置网格列数和占位规则（单元格合并）
- `StaggeredGridLayoutManager`：瀑布流管理器，可以设置列数，方向，是否倒序

### 数据更新

只修改数据列表并不会刷新界面上的视图，还需要通知适配器“数据已更新"，调用`notifyItemXXXX`方法，表示指定位置上的元素有变化，或调用`notifyDataSetChanged`表示整个数据列表都有变化



# 广播

广播一个`Intent`对象，作为跨`Activity`或`APP`传递数据

## 标准示例

接收器：

```java
public class MyBroadReceiver extends BroadcastReceiver {
    public static final String TAG = "receiver";
    public static final String ACTION = "abcedfg";

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, "onReceive: " + intent.getAction());
    }
}
```

Activity：

```java
private MyBroadReceiver receiver;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_broad);

    findViewById(R.id.btn_send).setOnClickListener(this);
}

@Override
public void onClick(View v) {
    // 点击按钮发送广播
    Intent intent = new Intent(MyBroadReceiver.ACTION);
    sendBroadcast(intent);
}

@Override
protected void onStart() {
    super.onStart();
    // 注册广播接收器
    receiver = new MyBroadReceiver();
    registerReceiver(receiver, new IntentFilter(MyBroadReceiver.ACTION));
}

@Override
protected void onStop() {
    super.onStop();
    // 注销广播接收器
    unregisterReceiver(receiver);
}
```

## 有序广播

当广播发送使用`sendOrderedBroadcast`方法发送时，为有序广播，此时：

1. 注册时使用的`IntentFilter`优先级越大的接收器越先收到广播，优先级使用`setPriority`方法设置
2. 优先级相同或未设置时，根据注册顺序先来后到
3. 先接收到广播的接收器可以调用`abortBroadcast`方法截断广播，此时后续的接收器无法接收到广播。

## 静态注册(不推荐)

使用`Android Studio`的模板功能可以创建和静态注册接收器，但是接收器想要接收到广播，需要在发送时指定接收器类的全名（相当于定向广播），实际上不实用。

```java
intent.setComponent(new ComponentName(this,"包名"));
```

## 接收系统广播

注册时将`IntentFilter`的`action`属性设置为对应值即可

| action                  | 说明       |
| ----------------------- | ---------- |
| Intent.ACTION_TIME_TICK | 整分钟广播 |
|                         |            |
|                         |            |

## 网络变更广播

```java
/**
 * 网络变更广播接收器
 *
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/6 17:11
 **/
public  class NetworkChangedReceiver extends BroadcastReceiver {
    public static final String ACTION = "android.net.conn.CONNECTIVITY_CHANGE";
    @NonNull
    private final NetworkChangedListener networkChangedListener;

    public NetworkChangedReceiver(@NonNull NetworkChangedListener networkChangedListener) {
        this.networkChangedListener = networkChangedListener;
    }

    /**
     * 注册
     *
     * @param contextWrapper 上下文
     */
    public final void register(ContextWrapper contextWrapper) {
        contextWrapper.registerReceiver(this, new IntentFilter(ACTION));
    }

    /**
     * 注销
     *
     * @param contextWrapper 上下文
     */
    public final void unregister(ContextWrapper contextWrapper) {
        contextWrapper.unregisterReceiver(this);
    }

    @Override
    public final void onReceive(Context context, Intent intent) {
        NetworkInfo networkInfo = intent.getParcelableExtra("networkInfo");
        int networkType = intent.getIntExtra("networkType", ConnectivityManager.TYPE_MOBILE);
        String extraInfo = intent.getStringExtra("extraInfo");
        int inetCondition = intent.getIntExtra("inetCondition", Integer.MIN_VALUE);
        // 回调
        networkChangedListener.onNetworkChanged(networkInfo, networkType, extraInfo, inetCondition);
    }


    public interface NetworkChangedListener {
        /**
         * 网络变更的回调
         *
         * @param networkInfo   网络信息
         * @param networkType   网络类型 从 ConnectivityManager.TYPE_xxxx中取值
         * @param extraInfo     未知数据
         * @param inetCondition 未知数据
         */
        void onNetworkChanged(NetworkInfo networkInfo, int networkType, String extraInfo, int inetCondition);
    }
}
```

## 发送定时广播

```java
// app上下文
Context context = getApplicationContext();
// 延时意图(发送广播)
PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_IMMUTABLE);
// 获取定时管理器
AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
// 发送意图的精确时间戳(毫秒)，本例为取当前时间戳+7秒，如果提供的毫秒数小于当前时间戳，则取当前时间戳向后延时5秒
long triggerAtMillis = System.currentTimeMillis() + 7 * 1000;
// 发送延时意图(安卓6.0以上)
alarmManager.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent);
// 取消广播
alarmManager.cancel(pendingIntent);
```

# Fragment(碎片)

可以将`Fragment`简单理解为一个小`Activity`，有自己的独立生命周期，有对应的布局文件，一般用于处理`Activity`中某一部分相对独立的业务逻辑。意图为方便管理和重用相对独立的业务逻辑。

## 静态注册

指直接在布局文件中使用`<fragment>`标签调用`Fragment`，此时该节点必须指定`id`属性，且必须使用`name`属性指定调用的`Fragment`类全名

使用`Android Studio`提供的模板可以快速创建`Fragment`及其对应的布局文件：`New - Fragment - Fragment(Blank)`。

- 自定义的`Fragment`类需要提供无参构造函数，否则系统无法自行创建对象。
- `Fragment`中可以使用`getArguments()`方法获取传入的参数，这样可以兼容动态注册方式，因此模板的`newInstance`方法中也采用了这种方式。

## 动态注册

指通过`Java`代码结合适配器，创建`Fragment`实例，旧方案为`ViewPager`+`FragmentPagerAdapter`，现在推荐使用`ViewPager2`+`FragmentStateAdapter`

1. 创建自定义适配器类，继承适配器抽象类，传入实体列表；实现其中的抽象方法来创建`Fragment`(推荐使用模板的`newInstance`)方法
2. 使用`setAdapter`方法装配适配器

# 主题和样式

`todo `

# Notification(通知推送)

## 权限申请

在`AndroidManifest.xml`中注册

```xml
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

## 获取通知管理器

```java
NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
```

## 获取通知通道

通知的id和name是自定义的，但同一个包下的id不能重复。

先检查之前是否已创建过，如果没有则创建

```java
NotificationChannel channel = manager.getNotificationChannel(DEFAULT_CHANNEL_ID);
if (channel == null) {
    System.out.println("未找到通道");
    channel = new NotificationChannel(DEFAULT_CHANNEL_ID, "CHANNEL_NAME_"+DEFAULT_CHANNEL_ID, NotificationManager.IMPORTANCE_DEFAULT);
}
```

## 创建并发送通知

```java
// 构建通知对象
Notification notification = new Notification.Builder(this, channel.getId())
        // 设置通知左上角的小图标(必填)
        .setSmallIcon(R.mipmap.ic_launcher)
        // 设置通知右下角的大图标
        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.logo1))
        .setSubText("附加文本")
        .setContentTitle("通知标题")
        .setContentText("通知正文")
        // 设置进度条 第三个参数为 true时模糊显示当前进度
        .setProgress(100, 70, true)
        .build();

// 这里的id也为自定义，如果需要取消通知则需要用到这个id
manager.notify(1, notification);
```

## Notification.Builder的其他方法

| 方法明           | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| setContentIntent | 设置一个延时意图，点击通知时触发意图，一般设置为打开某个`Activity` |
| setDeleteIntent  | 设置一个延时意图，划掉通知时触发意图                         |
| setAutoCancel    | 通知是否在被点击后自动移除，使用了`setContentIntent`才有效   |



## 封装工具类

```java
/**
 * 通知推送工具类
 *
 * @author : ginstone
 * @version : v1.0.0
 * @since : 2023/7/15 17:05
 **/
public class NotificationUtils {
    private static final String CHANNEL_NAME_PREFIX = "CHANNEL_NAME_";
    private static NotificationUtils notificationUtils;
    private final NotificationManager manager;
    private int id = 0;

    private NotificationUtils(Context context) {
        this.manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    }

    public static NotificationUtils getInstance(Context context) {
        if (notificationUtils == null) {
            notificationUtils = new NotificationUtils(context);
        }
        return notificationUtils;
    }

    /**
     * 获取通知通道，如果不存在指定id的通道，使用默认配置创建一个新的
     *
     * @param channelId 通道id
     * @return 通道
     */
    public NotificationChannel getChannel(String channelId) {
        NotificationChannel channel = manager.getNotificationChannel(channelId);
        if (channel != null) {
            return channel;
        }
        channel = new NotificationChannel(channelId, CHANNEL_NAME_PREFIX + channelId, NotificationManager.IMPORTANCE_DEFAULT);
        addChannel(channel);
        return channel;
    }


    /**
     * 添加通知通道
     *
     * @param notificationChannel 通知通道
     */
    public void addChannel(NotificationChannel notificationChannel) {
        manager.createNotificationChannel(notificationChannel);
    }

    /**
     * 发布一个通知
     *
     * @param notification 通知
     * @return 发布id
     */
    public int publish(Notification notification) {
        id++;
        manager.notify(id, notification);
        return id;
    }

    /**
     * 取消一个通知
     *
     * @param id 发布id
     */
    public void cancel(int id) {
        manager.cancel(id);
    }

    public NotificationManager getManager() {
        return manager;
    }
}
```

使用方法改为：

```java
NotificationUtils notificationUtils = NotificationUtils.getInstance(this);
NotificationChannel channel = notificationUtils.getChannel(DEFAULT_CHANNEL_ID);
notificationUtils.publish(notification);
```

# 导航

## 底部按钮导航快捷创建

`Android Studio`提供了快速创建模板：`New` - `Activity` - `Bottom Navigation Views Activity`，会自动创建`Activity`类，布局文件，以及对应需要的依赖包

```groovy
implementation 'androidx.navigation:navigation-fragment:2.5.2'
implementation 'androidx.navigation:navigation-ui:2.5.2'
```

此时需要把系统主题修改为带`ActionBar`的主题才能正常运行

## ToolBar顶部导航(NoActionBar方案)

因为`ActinoBar`已经被`ToolBar`淘汰，而快捷创建方式必须使用`ActionBar`，因此只能自己组合，一般采用`ViewPager2`作为翻页组件+`BottomNavigationView`作为导航按钮

参考：https://blog.csdn.net/qq_41912398/article/details/105816591

1. 新建一个空白`Activity`和布局文件，使用线性布局依次放入`Toolbar`、`ViewPager2`、`BottomNavigationView`


2. 为`ViewPager2`设置`FragmentStateAdapter`适配器，在适配器中初始化各个`Fragment`实例

3. 为`ViewPager2`设置滑动监听`registerOnPageChangeCallback`，当滑动到新一页时需要把`BottomNavigationView`的按钮也选中到该页

4. 为`BottomNavigationView`设置按钮选择监听`setOnNavigationItemSelectedListener`，当选中一个按钮时将`ViewPager`翻页到该页

参考代码



`Activity`布局文件：

   ```xml
   <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       xmlns:tools="http://schemas.android.com/tools"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:orientation="vertical"
       tools:context=".activity.ToolBarNaviActivity">
   
       <androidx.appcompat.widget.Toolbar
           android:id="@+id/toolbar"
   		app:navigationIcon="@mipmap/ic_back"
           android:layout_width="match_parent"
           android:layout_height="wrap_content" />
   
       <androidx.viewpager2.widget.ViewPager2
           android:id="@+id/vp2"
           android:layout_width="match_parent"
           android:layout_height="0dp"
           android:layout_weight="1" />
   
       <com.google.android.material.bottomnavigation.BottomNavigationView
           android:id="@+id/nav_view"
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:background="?android:attr/windowBackground"
           app:menu="@menu/bottom_nav_menu" />
   </LinearLayout>
   ```

JAVA：

```java
private final List<Class<?>> fragments = new ArrayList<>(Arrays.asList(HomeFragment.class, MeFragment.class, NoticeFragment.class));
private Toolbar toolbar;
private ViewPager2 vp2;
private BottomNavigationView nav;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.i(TAG, "onCreate");
    setContentView(R.layout.activity_tool_bar_navi);

    toolbar = findViewById(R.id.toolbar);
    vp2 = findViewById(R.id.vp2);
    nav = findViewById(R.id.nav_view);

    // 设置ToolBar为ActionBar
    setSupportActionBar(toolbar);
    // 设置导航按钮作用为关闭 Activity
    toolbar.setNavigationOnClickListener(view->finish());

    // ViewPager2切换页面时，同步修改导航栏的选中项
    vp2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() {
        @Override
        public void onPageSelected(int position) {
            super.onPageSelected(position);
            MenuItem menuItem = nav.getMenu().getItem(position);
            // 修改选中项
            menuItem.setChecked(true);
            // 修改toolbar标题
            toolbar.setTitle(menuItem.getTitle());
        }
    });
    // 点击导航按钮的剪影，同步切换ViewPager2的页面
    nav.setOnItemSelectedListener(item -> {
        int itemId = item.getItemId();
        if (R.id.navigation_home == itemId) {
            vp2.setCurrentItem(0);
        }
        if (R.id.navigation_dashboard == itemId) {
            vp2.setCurrentItem(1);
        }
        if (R.id.navigation_notifications == itemId) {
            vp2.setCurrentItem(2);
        }
        toolbar.setTitle(item.getTitle());
        return true;
    });
}

@Override
protected void onResume() {
    super.onResume();

    // 设置适配器，适配器中初始化Fragment
    vp2.setAdapter(new FragmentStateAdapter(getSupportFragmentManager(), getLifecycle()) {
        @NonNull
        @Override
        public Fragment createFragment(int position) {
            Class<?> aClass = fragments.get(position);
            try {
                return (Fragment) aClass.newInstance();
            } catch (IllegalAccessException | InstantiationException e) {
                e.printStackTrace();
                return null;
            }
        }

        @Override
        public int getItemCount() {
            return fragments.size();
        }
    });
}

@Override
protected void onPause() {
    super.onPause();
    vp2.setAdapter(null);
}
```

## OverflowMenu(溢出菜单)

溢出菜单指的是通常出现在顶端导航栏右侧的三点图标，点击后会展开一个菜单，内部按钮也可能出现在三点按钮左侧。

在`res/menu`目录下创建布局文件：

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/refresh"
        android:icon="@drawable/ic_refresh_24"
        android:title="@string/refresh"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/search"
        android:icon="@drawable/ic_search_24"
        android:title="@string/search" />
    <item
        android:id="@+id/notice"
        android:icon="@drawable/ic_notice_24"
        android:title="@string/notice" />
</menu>
```

在`Activity`中重写方法

```java
/**
 * 装载溢出菜单
 */
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_overflow_menu, menu);
    return true;
}

/**
 * 点击溢出菜单项的回调
 */
@Override
public boolean onOptionsItemSelected(@NonNull MenuItem item) {
    int itemId = item.getItemId();
    if (itemId == R.id.refresh) {
        Log.i(TAG, "onOptionsItemSelected: 刷新");
    }
    if (itemId == R.id.search) {
        Log.i(TAG, "onOptionsItemSelected: 搜索");
    }
    if (itemId == R.id.notice) {
        Log.i(TAG, "onOptionsItemSelected: 消息");
    }
    return super.onOptionsItemSelected(item);
}
```



# APP打包

## 打包为APK

1. 以此选择`Build - Generate Signed Bundle / APK`，选择`APK - Next`
2. 打包需要一个证书文件，如果之前已经打包过就直接用之前的文件，并填写证书和别名两个密码
3. 如果是第一打包，选择`Create new`，
   1. 选择证书文件保存路径，填写证书密码
   2. 填写`Alias`(别名，自定义)，填写别名密码
   3. 填写`First and Last Name`（姓名，自定义）
   4. 点击`Ok`，建议勾上记住密码
4. 点`Next`，选择版本，测试版本选`debug`，正式发布选`release`，点`Finish`

## 制作APP图标

右键`res/mimap`选择`New - Image Asset`

`Icon type`选择`Launcher Icons (Adaptive and Legacy)`

`Asset type`选择`Image`，然后选择自己话的图标文件，配置其他选项即可制作出不同规格的APP图标

## APK瘦身

- `AndroidManifest.xml`文件的`<application>`节点，可以将`allowBackup`和`supportsRtl`属性设置为`false`
- 模块的`build.gradle`文件`android - buildTypes - release`节点，`minifyEnabled` 属性修改为`true`，添加属性`shrinkResources`，设置为`true`

# 拦截返回键

要求用户在3秒内连续按2此返回键才能退出`Activity`

```java
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (quitConfirm) {
            finish();
            return true;
        }
        quitConfirm = true;
        Toast.makeText(this, "再按一次退出", Toast.LENGTH_SHORT).show();
        handler.postDelayed(() -> {
            quitConfirm = false;
        }, 3000);
        return true;
    }

    return super.onKeyDown(keyCode, event);
}
```

# Handler(多线程)

`Android`规定只有主线程（即UI线程）才能操作界面上的UI，且同时主线程不允许执行一系列耗时操作（网络请求等）。因此通常通过`Handler`来实现：在分线程中执行耗时操作，将结果返回给主线程修改UI。

## Message(消息)

`Handler`通过`Message`对象来从分线程返回结果，相当于一个返回结果的包装，`Message`类通过`Message.obtain()`或`handler.obtainMessage()`初始化。它的常用属性如下：

| 属性 | 数据类型 | 说明                             |
| ---- | -------- | -------------------------------- |
| what | int      | 一般用来标识消息类型             |
| arg1 | int      | 可自行规定含义，如消息的细分类型 |
| arg2 | int      | 可自行规定含义，如执行结果       |
| obj  | Object   | 任意对象                         |

消息构筑完成之后通过`Handler`对象的`sendMessageXXX`方法发送出去。另外`Handler`对象的`sendEmptyMessageXXX`方法将会直接发送一个指定`what`属性，其他为空的消息。发送出去的消息将会传递给`Handler`对象的`handleMessage`方法。

## handleMessage(处理消息)

重写`Handler`对象的`handleMessage`方法，根据`Message`对象中传递的参数对UI进行操作

## 内存泄露的处理

参考网络文章：

1. **https://blog.csdn.net/weixin_38090079/article/details/130289079**
2. https://cloud.tencent.com/developer/article/1731211

这里采用独立类+弱引用+清空消息队列的方法：



自定义类继承`Handler`，在其中弱引用持有`Activity`，并要求提供回调方法，当引用存在时执行回调方法：

```java
public class MyHandler extends Handler {
    private final WeakReference<AppCompatActivity> weakReference;
    private final Callback callback;

    public MyHandler(@NonNull AppCompatActivity activity, @NonNull Callback callback) {
        super(Looper.myLooper());
        this.weakReference = new WeakReference<>(activity);
        this.callback = callback;
    }

    @Override
    public void handleMessage(@NonNull Message msg) {
        AppCompatActivity activity = weakReference.get();
        if (activity != null) {
            callback.handleMessage(msg);
        }
    }
    
    /**
     * 在Activity的 onDestroy 方法中执行
     */
    public void onDestroy() {
        removeCallbacksAndMessages(null);
    }

    public interface Callback {
        void handleMessage(@NonNull Message msg);
    }
}
```

`Activity`类

1. 创建`MyHandler`对象
2. 实现`MyHandler.Callback`接口
3. 在`onDestroy`方法中调用`MyHandler`的`onDestroy`方法

如果不执行`removeCallbacksAndMessages`方法，即使在`Actitivy`被销毁(`onDestroy`)之后，甚至在退出APP但未杀死进程时，`Handler`都依然会继续运行，但实际上按照`Handler`的职责，当`Activity `销毁后就应当停止运行。
